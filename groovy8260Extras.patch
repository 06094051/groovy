Index: src/test/groovy/transform/stc/MiscSTCTest.groovy
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/test/groovy/transform/stc/MiscSTCTest.groovy	(revision 456aa4dd37dbcebcfb263db2914b2d84246bc30f)
+++ src/test/groovy/transform/stc/MiscSTCTest.groovy	(revision )
@@ -275,5 +275,64 @@
     public static class MiscSTCTestSupport {
         static def foo() { '123' }
     }
+
+    void testTernaryParam() {
+        assertScript '''
+            Date ternaryParam(Object input) {
+                input instanceof Date ? input : null
+            }
+            def d = new Date()
+            assert ternaryParam(42) == null
+            assert ternaryParam('foo') == null
+            assert ternaryParam(d) == d
+        '''
+    }
+
+    void testTernaryLocalVar() {
+        assertScript '''
+            Date ternaryLocalVar(Object input) {
+                Object copy = input
+                copy instanceof Date ? copy : null
+            }
+            def d = new Date()
+            assert ternaryLocalVar(42) == null
+            assert ternaryLocalVar('foo') == null
+            assert ternaryLocalVar(d) == d
+        '''
+    }
+
+    void testIfThenElseParam() {
+        assertScript '''
+            Date ifThenElseParam(Object input) {
+                if (input instanceof Date) {
+                    input
+                } else {
+                    null
+                }
+            }
+            def d = new Date()
+            assert ifThenElseParam(42) == null
+            assert ifThenElseParam('foo') == null
+            assert ifThenElseParam(d) == d
+        '''
+    }
+
+    void testIfThenElseLocalVar() {
+        assertScript '''
+            Date ifThenElseLocalVar(Object input) {
+                Date result
+                if (input instanceof Date) {
+                    result = input
+                } else {
+                    result = null
+                }
+                result
+            }
+            def d = new Date()
+            assert ifThenElseLocalVar(42) == null
+            assert ifThenElseLocalVar('foo') == null
+            assert ifThenElseLocalVar(d) == d
+        '''
+    }
 }
 
Index: src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java	(revision 456aa4dd37dbcebcfb263db2914b2d84246bc30f)
+++ src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java	(revision )
@@ -112,7 +112,6 @@
 import static org.codehaus.groovy.syntax.Types.COMPARE_EQUAL;
 import static org.codehaus.groovy.syntax.Types.COMPARE_NOT_EQUAL;
 import static org.codehaus.groovy.syntax.Types.COMPARE_NOT_IN;
-import static org.codehaus.groovy.syntax.Types.COMPARE_NOT_INSTANCEOF;
 import static org.codehaus.groovy.syntax.Types.COMPARE_TO;
 import static org.codehaus.groovy.syntax.Types.DIVIDE;
 import static org.codehaus.groovy.syntax.Types.DIVIDE_EQUAL;
@@ -483,7 +482,20 @@
             }
         }
 
-        if (! (vexp.getAccessedVariable() instanceof DynamicVariable)) return;
+        if (! (vexp.getAccessedVariable() instanceof DynamicVariable)) {
+            //if (vexp.getAccessedVariable() instanceof Parameter) {
+                ClassNode inferredTypeFromTempInfo = getInferredTypeFromTempInfo(vexp, null);
+                if (inferredTypeFromTempInfo != null) {
+                    storeType(vexp, inferredTypeFromTempInfo);
+                }
+//            } else if (vexp.getAccessedVariable() instanceof VariableExpression) {
+//                ClassNode inferredTypeFromTempInfo = getInferredTypeFromTempInfo((Expression) vexp.getAccessedVariable(), null);
+//                if (inferredTypeFromTempInfo != null) {
+//                    storeType((Expression) vexp.getAccessedVariable(), inferredTypeFromTempInfo);
+//                }
+//            }
+            return;
+        }
 
         // a dynamic variable is either an undeclared variable
         // or a member of a class used in a 'with'
@@ -668,6 +680,9 @@
                 if (typeCheckingContext.ifElseForWhileAssignmentTracker != null && leftExpression instanceof VariableExpression
                         && !isNullConstant(rightExpression)) {
                     Variable accessedVariable = ((VariableExpression) leftExpression).getAccessedVariable();
+                    if (accessedVariable instanceof Parameter) {
+                        accessedVariable = new ParameterVariableExpression((Parameter) accessedVariable);
+                    }
                     if (accessedVariable instanceof VariableExpression) {
                         VariableExpression var = (VariableExpression) accessedVariable;
                         List<ClassNode> types = typeCheckingContext.ifElseForWhileAssignmentTracker.get(var);
@@ -1947,40 +1962,48 @@
     protected ClassNode[] getArgumentTypes(ArgumentListExpression args) {
         List<Expression> arglist = args.getExpressions();
         ClassNode[] ret = new ClassNode[arglist.size()];
-        int i = 0;
-        Map<Object, List<ClassNode>> info = typeCheckingContext.temporaryIfBranchTypeInformation.empty() ? null : typeCheckingContext.temporaryIfBranchTypeInformation.peek();
-        for (Expression exp : arglist) {
-            if (isNullConstant(exp)) {
+        for (int i = 0; i < arglist.size(); i++) {
+            if (isNullConstant(arglist.get(i))) {
                 ret[i] = UNKNOWN_PARAMETER_TYPE;
             } else {
-                ret[i] = getType(exp);
-                if (exp instanceof VariableExpression && info != null) {
-                    List<ClassNode> classNodes = getTemporaryTypesForExpression(exp);
-                    if (classNodes != null && !classNodes.isEmpty()) {
-                        ArrayList<ClassNode> arr = new ArrayList<ClassNode>(classNodes.size() + 1);
-                        arr.add(ret[i]);
-                        arr.addAll(classNodes);
-                        // GROOVY-7333: filter out Object
-                        Iterator<ClassNode> iterator = arr.iterator();
-                        while (iterator.hasNext()) {
-                            ClassNode next = iterator.next();
-                            if (ClassHelper.OBJECT_TYPE.equals(next)) {
-                                iterator.remove();
-                            }
-                        }
-                        if (arr.isEmpty()) {
-                            ret[i] = ClassHelper.OBJECT_TYPE.getPlainNodeReference();
-                        } else if (arr.size()==1) {
-                            ret[i] = arr.get(0);
-                        } else {
-                            ret[i] = new UnionTypeClassNode(arr.toArray(new ClassNode[arr.size()]));
-                        }
-                    }
+                ret[i] = getInferredType(arglist.get(i));
+            }
+        }
+        return ret;
+    }
+
+    private ClassNode getInferredType(Expression exp) {
+        ClassNode result = getType(exp);
+        result = getInferredTypeFromTempInfo(exp, result);
+        return result;
+    }
+
+    private ClassNode getInferredTypeFromTempInfo(Expression exp, ClassNode result) {
+        Map<Object, List<ClassNode>> info = typeCheckingContext.temporaryIfBranchTypeInformation.empty() ? null : typeCheckingContext.temporaryIfBranchTypeInformation.peek();
+        if (exp instanceof VariableExpression && info != null) {
+            List<ClassNode> classNodes = getTemporaryTypesForExpression(exp);
+            if (classNodes != null && !classNodes.isEmpty()) {
+                ArrayList<ClassNode> arr = new ArrayList<ClassNode>(classNodes.size() + 1);
+                if (result != null) arr.add(result);
+                arr.addAll(classNodes);
+                // GROOVY-7333: filter out Object
+                Iterator<ClassNode> iterator = arr.iterator();
+                while (iterator.hasNext()) {
+                    ClassNode next = iterator.next();
+                    if (ClassHelper.OBJECT_TYPE.equals(next)) {
+                        iterator.remove();
+                    }
+                }
+                if (arr.isEmpty()) {
+                    result = ClassHelper.OBJECT_TYPE.getPlainNodeReference();
+                } else if (arr.size()==1) {
+                    result = arr.get(0);
+                } else {
+                    result = new UnionTypeClassNode(arr.toArray(new ClassNode[arr.size()]));
                 }
             }
-            i++;
         }
-        return ret;
+        return result;
     }
 
     @Override
@@ -4026,6 +4049,9 @@
                 List<ClassNode> temporaryTypesForExpression = getTemporaryTypesForExpression(vexp);
                 if (temporaryTypesForExpression == null || temporaryTypesForExpression.isEmpty()) {
                     type = typeCheckingContext.controlStructureVariables.get(parameter);
+//                } else {
+//                    ClassNode temp = getInferredTypeFromTempInfo((Expression) exp, null);
+//                    type = temp;
                 }
                 // now check for closure override
                 TypeCheckingContext.EnclosingClosure enclosingClosure = typeCheckingContext.getEnclosingClosure();
@@ -4849,4 +4875,65 @@
         }
     }
 
+    /**
+     * Wrapper for a Parameter so it can be treated like a VariableExpression
+     * and tracked in the ifElseForWhileAssignmentTracker.
+     *
+     * This class purposely does not adhere to the normal equals and hashCode
+     * contract on the Object class and delegates those calls to the wrapped
+     * variable.
+     */
+    private static class ParameterVariableExpression extends VariableExpression {
+
+        private final Parameter parameter;
+
+        ParameterVariableExpression(Parameter parameter) {
+            super(parameter);
+            this.parameter = parameter;
+            ClassNode inferred = parameter.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);
+            if (inferred == null) {
+                parameter.setNodeMetaData(StaticTypesMarker.INFERRED_TYPE, parameter.getOriginType());
+            }
+        }
+
+        @Override
+        public void copyNodeMetaData(ASTNode other) {
+            parameter.copyNodeMetaData(other);
+        }
+
+        @Override
+        public Object putNodeMetaData(Object key, Object value) {
+            return parameter.putNodeMetaData(key, value);
+        }
+
+        @Override
+        public void removeNodeMetaData(Object key) {
+            parameter.removeNodeMetaData(key);
+        }
+
+        @Override
+        public Map<?, ?> getNodeMetaData() {
+            return parameter.getNodeMetaData();
+        }
+
+        @Override
+        public <T> T getNodeMetaData(Object key) {
+            return parameter.getNodeMetaData(key);
+        }
+
+        @Override
+        public void setNodeMetaData(Object key, Object value) {
+            parameter.setNodeMetaData(key, value);
+        }
+
+        @Override
+        public int hashCode() {
+            return parameter.hashCode();
+        }
+
+        @Override
+        public boolean equals(Object other) {
+            return parameter.equals(other);
+        }
+    }
 }
Index: src/test/groovy/transform/stc/STCAssignmentTest.groovy
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/test/groovy/transform/stc/STCAssignmentTest.groovy	(revision 456aa4dd37dbcebcfb263db2914b2d84246bc30f)
+++ src/test/groovy/transform/stc/STCAssignmentTest.groovy	(revision )
@@ -446,6 +446,21 @@
         ''', 'Cannot find matching method java.io.Serializable#toInteger()'
     }
 
+    void testIfElseBranchParameter() {
+        shouldFailWithMessages '''
+            def foo(x) {
+                def y = 'foo'
+                if (y) {
+                    x = new HashSet()
+                } else {
+                    x = '123'
+                }
+                x.toInteger()
+            }
+            foo('bar')
+        ''', 'Cannot find matching method java.lang.Object#toInteger()'
+    }
+
     void testIfOnly() {
         shouldFailWithMessages '''
             def x = '123'
@@ -457,6 +472,20 @@
         ''', 'Cannot find matching method java.io.Serializable#toInteger()'
     }
 
+    void testIfOnlyParameter() {
+        shouldFailWithMessages '''
+            def foo(x) {
+                def y = 'foo'
+                if (y) {
+                    x = new HashSet()
+                    assert x.isEmpty()
+                }
+                x.toInteger()
+            }
+            foo('123')
+        ''', 'Cannot find matching method java.lang.Object#toInteger()'
+    }
+
     void testIfWithCommonInterface() {
         assertScript '''
             interface Foo { void foo() }
@@ -872,5 +901,63 @@
         }            
         '''
     }
-}
+
+    // GROOVY-8220
+    void testFlowTypingParameterTempTypeAssignmentTracking() {
+        assertScript '''
+            class Foo {
+                CharSequence makeEnv( env, StringBuilder result = new StringBuilder() ) {
+                    if (env instanceof File) {
+                        env = env.toPath()
+                    }
+                    if (env instanceof String && env.contains('=')) {
+                        result << 'export ' << env << ';'
+                    }
+                    return result.toString()
+                }
+            }
+            assert new Foo().makeEnv('X=1') == 'export X=1;'
+        '''
+        // GROOVY-8237
+        assertScript '''
+            class Foo {
+                String parse(Reader reader) {
+                    if (reader == null)
+                        reader = new BufferedReader(reader)
+                    int i = reader.read()
+                    return (i != -1) ? 'bar' : 'baz'
+                }
+            }
+            assert new Foo().parse(new StringReader('foo')) == 'bar'
+        '''
+    }
 
+    void testFlowTypingParameterTempTypeAssignmentTrackingWithGenerics() {
+        assertScript '''
+            class M {
+                Map<String, List<Object>> mvm = new HashMap<String, List<Object>>()
+                void setProperty(String name, value) {
+                    if (value instanceof File) {
+                        value = new File(value, 'bar.txt')
+                    }
+                    else if (value instanceof URL) {
+                        value = value.toURI()
+                    }
+                    else if (value instanceof InputStream) {
+                        value = new BufferedInputStream(value)
+                    }
+                    else if (value instanceof GString) {
+                        value = value.toString()
+                    }
+                    if (mvm[name]) {
+                        mvm[name].add value
+                    } else {
+                        mvm.put(name, [value])
+                    }
+                }
+            }
+            new M().setProperty('foo', 'bar')
+        '''
+    }
+
+}
