/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 *//*
package org.apache.groovy.transform;

import groovy.transform.MapArguments;
import org.codehaus.groovy.ast.ASTNode;
import org.codehaus.groovy.ast.AnnotationNode;
import org.codehaus.groovy.ast.ClassHelper;
import org.codehaus.groovy.ast.ClassNode;
import org.codehaus.groovy.ast.ConstructorNode;
import org.codehaus.groovy.ast.MethodNode;
import org.codehaus.groovy.ast.Parameter;
import org.codehaus.groovy.ast.expr.ArgumentListExpression;
import org.codehaus.groovy.ast.expr.Expression;
import org.codehaus.groovy.ast.expr.VariableExpression;
import org.codehaus.groovy.control.CompilePhase;
import org.codehaus.groovy.control.SourceUnit;
import org.codehaus.groovy.transform.AbstractASTTransformation;
import org.codehaus.groovy.transform.GroovyASTTransformation;
import org.objectweb.asm.Opcodes;

import java.util.ArrayList;
import java.util.List;

import static org.apache.groovy.ast.tools.FactoryUtils.args;
import static org.apache.groovy.ast.tools.FactoryUtils.callThisX;
import static org.apache.groovy.ast.tools.FactoryUtils.castX;
import static org.apache.groovy.ast.tools.FactoryUtils.classX;
import static org.apache.groovy.ast.tools.FactoryUtils.constX;
import static org.apache.groovy.ast.tools.FactoryUtils.ctorX;
import static org.apache.groovy.ast.tools.FactoryUtils.stmt;
import static org.apache.groovy.ast.tools.FactoryUtils.varX;

@GroovyASTTransformation(phase = CompilePhase.SEMANTIC_ANALYSIS)
public class MapArgumentsASTTransformation extends AbstractASTTransformation {

    @Override
    public void visit(ASTNode[] nodes, SourceUnit source) {
        init(nodes, source);

        MethodNode methodNode = (MethodNode) nodes[1];

        Parameter[] parameters = methodNode.getParameters();
        Parameter closureParameter = null;

        switch (parameters.length) {
            case 0:
                addError("MapArguments parameters should not be empty", methodNode);
                return;
            case 1:
                //TODO more object checks
                break;
            case 2:
                closureParameter = parameters[1];
                if (!(closureParameter.getType().isDerivedFrom(ClassHelper.CLOSURE_TYPE)) && !ClassHelper.isSAMType(closureParameter.getType())) {
                    addError("MapArguments second parameter can be a closure only", closureParameter);
                    return;
                }
                break;
            default:
                addError("MapArguments parameters length should not be greater than 2", methodNode);
                return;
        }

        Parameter mapParameter = new Parameter(nonGeneric(ClassHelper.MAP_TYPE), "__namedArgs");

        Parameter[] mapBasedMethodParameters = closureParameter != null ? new Parameter[]{mapParameter, closureParameter} : new Parameter[]{mapParameter};

        ClassNode declaringClass = methodNode.getDeclaringClass();

        if (declaringClass.hasMethod(methodNode.getName(), mapBasedMethodParameters)) {
            addError("This class already has a Map-based method", methodNode);
            return;
        }

        Expression convertedValueExpression;

        ClassNode parameterType = parameters[0].getType();
        if (checkForMapConstructor(parameterType)) {
            ArgumentListExpression convertedArguments = args(varX(mapParameter));
            if ((parameterType.getModifiers() & Opcodes.ACC_STATIC) == 0) {
                if(methodNode.isStatic()) {
                    addError("You can't use inner class as map argument since it's impossible to instantiate it", methodNode);
                    return;
                }
                convertedArguments.getExpressions().add(0, VariableExpression.THIS_EXPRESSION);
            }
            convertedValueExpression = ctorX(parameterType, convertedArguments);
        } else {
            convertedValueExpression = castX(parameterType, varX(mapParameter));
        }

        ArgumentListExpression oldMethodArguments = FactoryUtils.args(convertedValueExpression);

        List<MethodNode> generatedMethods = new ArrayList<MethodNode>();
        generatedMethods.add(declaringClass.addMethod(
                methodNode.getName(),
                methodNode.getModifiers(),
                methodNode.getReturnType(),
                mapBasedMethodParameters,
                methodNode.getExceptions(),
                stmt(callThisX(methodNode.getName(), oldMethodArguments))
        ));

        if (closureParameter != null) {
            oldMethodArguments.addExpression(varX(closureParameter));
            generatedMethods.add(declaringClass.addMethod(
                    methodNode.getName(),
                    methodNode.getModifiers(),
                    methodNode.getReturnType(),
                    new Parameter[]{mapBasedMethodParameters[0]},
                    methodNode.getExceptions(),
                    stmt(callThisX(
                            methodNode.getName(),
                            args(oldMethodArguments.getExpression(0), castX(closureParameter.getType(), constX(null)))
                    ))
            ));
        }

        for (MethodNode generatedMethod : generatedMethods) {
            AnnotationNode mapArgumentsAnnotationNode = new AnnotationNode(ClassHelper.makeWithoutCaching(MapArguments.class));
            mapArgumentsAnnotationNode.setMember("typeHint", classX(parameterType));
            generatedMethod.addAnnotation(mapArgumentsAnnotationNode);
        }
    }

    protected boolean checkForMapConstructor(ClassNode parameterType) {
        List<ConstructorNode> declaredConstructors = parameterType.getDeclaredConstructors();

        for (ConstructorNode declaredConstructor : declaredConstructors) {
            Parameter[] declaredConstructorParameters = declaredConstructor.getParameters();
            if (declaredConstructorParameters.length != 1) {
                continue;
            }

            ClassNode declaredConstructorParameterType = declaredConstructorParameters[0].getType();

            if (declaredConstructorParameterType == null) {
                continue;
            }

            if (declaredConstructorParameterType.equals(ClassHelper.MAP_TYPE)) {
                return true;
            }
        }

        return false;
    }
}