= Metaprogramming

The Groovy language supports two flavors of metaprogramming: runtime metaprogramming and compile-time metaprogramming.
The first one allows altering the class model and the behavior of a program at runtime, while the second only occurs
at compile-time. Both have pros and cons, that we will detail in this section.

== Runtime metaprogramming

=== GroovyObject interface
==== invokeMethod
==== get/setProperty
==== get/setMetaClass

=== get/setAttribute
=== propertyMissing
=== methodMissing
=== GroovyInterceptable
=== Categories

=== Metaclasses
==== Custom metaclasses
===== Delegating metaclass
===== Magic package
==== Per instance metaclass
==== ExpandoMetaClass
===== Constructors
===== Borrowing methods
===== Dynamic method names
===== GroovyObject methods
===== Overriding static invokeMethod
===== Properties
===== Runtime discovery
===== Static methods

=== Extension modules
==== Module descriptor
==== Instance methods
==== Static methods

== Compile-time metaprogramming

Compile-time metaprogramming in Groovy allows code generation at compile-time. Those transformations are altering the
Abstract Syntax Tree (AST) of a program, which is why in Groovy we call it AST transformations. AST transformations
allow you to hook into the compilation process, modify the AST and continue the compilation process to generate regular
bytecode. Compared to runtime metaprogramming, this has the advantage of making the changes visible in the class file
itself (that is to say, in the bytecode). Making it visible in the bytecode is important for example if you want the
transformations to be part of the class contract (implementing interfaces, extending abstract classes, ...) or even
if you need your class to be callable from Java (or other JVM languages). For example, an AST transformation can add
methods to a class. If you do it with runtime metaprogramming, the new method would only be visible from Groovy. If you
do the same using compile-time metaprogramming, the method would be visible from Java too. Last but not least, performance
would likely be better with compile-time metaprogramming (because no initialization phase is required).

In this section, we will start with explaining the various compile-time transformations that are bundled with the Groovy
distribution. In a second time, we will describe how you can <<developing-ast-xforms,implement your own AST transformations>>
and what are the disadvantages of this technique.

=== Available AST transformations

Groovy comes with various AST transformations covering different needs: reducing boilerplate (code generation), implementing
design patterns (delegation, ...), logging, declarative concurrency, cloning, safer scripting, tweaking the compilation,
implementing Swing patterns, testing and eventually managing dependencies. If none of those AST transformations cover
your needs, you can still implement your own, as show in section <<developing-ast-xforms,Developping your own AST
transformations>>.

AST transformations can be separated into two categories:

* global AST transformations are applied transparently, globally, as soon as they are found on compile classpath
* local AST transformations are applied by annotating the source code with markers. Unlike global AST transformations,
local AST transformations may support parameters.

Groovy doesn't ship with any global AST transformation, but you can find a list of local AST transformations
available for you to use in your code here:

==== Code generation transformations

This category of transformation includes AST transformations which helps removing boilerplate code. This is typically
code that you have to write but that does not carry any useful information.

[[xform-ToString]]
===== @groovy.transform.ToString
The `@ToString` AST transformation generates a human readable `toString` representation of the class. For example,
annotating the `Person` class like below will automatically generate the `toString` method for you:

[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tostring_import,indent=0]

include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tostring_simple,indent=0]
----

With this definition, then the following assertion passes, meaning that a `toString` method taking the field valuess from
the class and printing them out has been generated:

[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tostring_simple_assert,indent=0]
----

The `@ToString` annotation accepts several parameters which are summarized in the following table:

[cols="1,1,2,3a",options="header"]
|=======================================================================
|Attribute|Default value|Description|Example
|includeNames|false|Whether to include names of properties in generated toString.|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tostring_example_includeNames,indent=0]
----
|excludes|Empty list|List of properties to exclude from toString|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tostring_example_excludes,indent=0]
----
|includes|Empty list|List of fields to include in toString|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tostring_example_includes,indent=0]
----
|includeSuper|False|Should superclass be included in toString|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tostring_example_includeSuper,indent=0]
----
|includeFields|False|Should fields be included in toString, in addition to properties|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tostring_example_includeFields,indent=0]
----
|ignoreNulls|False|Should properties/fields with null value be displayed|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tostring_example_ignoreNulls,indent=0]
----
|includePackage|False|Use fully qualified class name instead of simple name in toString|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tostring_example_includePackage,indent=0]
----
|cache|False|Cache the toString string. Should only be set to true if the class is immutable.|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tostring_example_cache,indent=0]
----

|=======================================================================

[[xform-EqualsAndHashCode]]
===== @groovy.transform.EqualsAndHashCode

The `@EqualsAndHashCode` AST transformation aims at generating `equals` and `hashCode` methods for you. The generated
hashcode follows the best practices as described in _Effective Java_ by _Josh Bloch_:

[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=equalshashcode,indent=0]
----

There are several options available to tweak the behavior of `@EqualsAndHashCode`:

[cols="1,1,2,3a",options="header"]
|=======================================================================
|Attribute|Default value|Description|Example
|excludes|Empty list|List of properties to exclude from equals/hashCode|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=equalshashcode_example_excludes,indent=0]
----
|includes|Empty list|List of fields to include in equals/hashCode|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=equalshashcode_example_includes,indent=0]
----
|callSuper|False|Whether to include super in equals and hashCode calculations|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=equalshashcode_example_super,indent=0]
----
|includeFields|False|Should fields be included in equals/hashCode, in addition to properties|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tostring_example_includeFields,indent=0]
----
|cache|False|Cache the hashCode computation. Should only be set to true if the class is immutable.|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tostring_example_cache,indent=0]
----
|useCanEqual|True|Should equals call canEqual helper method.|See http://www.artima.com/lejava/articles/equality.html
|=======================================================================

[[xform-TupleConstructor]]
===== @groovy.transform.TupleConstructor

The `@TupleConstructor` annotation aims at eliminating boilerplate code by generating constructors for you. A tuple
constructor is created for each property, with default values (using the Java default values). For example, the
following code will generate 3 constructors:

[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tupleconstructor_simple,indent=0]
----

The first constructor is a no-arg constructor which allows the traditional map-style construction. It is worth noting
that if the first property (or field) has type LinkedHashMap or if there is a single Map, AbstractMap or HashMap
property (or field), then the map-style mapping is not available.

The other constructors are generated by taking the properties in the order they are defined. Groovy will generate as
many constructors as they are properties (or fields, depending on the options).

The `@TupleConstructor` AST transformation accepts several configuration options:

[cols="1,1,2,3a",options="header"]
|=======================================================================
|Attribute|Default value|Description|Example
|excludes|Empty list|List of properties to exclude from tuple constructor generation|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tupleconstructor_example_excludes,indent=0]
----
|includes|Empty list|List of fields to include in tuple constructor generation|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tupleconstructor_example_includes,indent=0]
----
|includeFields|False|Should fields be included in tuple constructor generation, in addition to properties|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tupleconstructor_example_includeFields,indent=0]
----
|includeProperties|True|Should properties be included in tuple constructor generation|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tupleconstructor_example_includeProperties,indent=0]
----
|includeSuperFields|False|Should fields from super classes be included in tuple constructor generation|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tupleconstructor_example_includeSuperFields,indent=0]
----
|includeSuperProperties|True|Should properties from super classes be included in tuple constructor generation|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tupleconstructor_example_includeSuperProperties,indent=0]
----
|callSuper|False|Should super properties be called within a call to the parent constructor rather than set as properties|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tupleconstructor_example_callSuper,indent=0]
----
|force|False|By default, the transformation will do nothing if a constructor is already defined. Setting this property
to true, the constructor will be generated and it's your responsability to ensure that no duplicate constructor
is defined|See javadocs
|=======================================================================

[[xform-Canonical]]
===== @groovy.transform.Canonical

The `@Canonical` AST transformation combines the effects of the <<xform-ToString,@ToString>>,
<<xform-EqualsAndHashCode,@EqualsAndHashCode>> and <<xform-TupleConstructor,@TupleConstructor>>
annotations:

[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=canonical_simple,indent=0]
----

A similar immutable class can be generated using the <<xform-Immutable,@Immutable>> AST transformation instead.
The `@Canonical` AST transformation supports several configuration options:

[cols="1,1,2,3a",options="header"]
|=======================================================================
|Attribute|Default value|Description|Example
|excludes|Empty list|List of properties to exclude from tuple constructor generation|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=canonical_example_excludes,indent=0]
----
|includes|Empty list|List of fields to include in tuple constructor generation|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=canonical_example_includes,indent=0]
----
|=======================================================================

[[xform-InheritConstructors]]
===== @groovy.transform.InheritConstructors

The `@InheritConstructor` AST transformation aims at generating constructors matching super constructors for you. This
is in particular useful when overridding exception classes:

[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=inheritconstructors_simple,indent=0]
----

[[xform-Category]]
===== @groovy.lang.Category

The `@Category` AST transformation simplifies the creation of Groovy categories. Historically, a Groovy category was
written like this:

[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=oldstyle_category,indent=0]
----

The `@Category` transformation lets you write the same using an instance-style class, rather that a static class style.
This removes the need for having the first argument of each method being the receiver. The category can be written like
this:

[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=newstyle_category,indent=0]
----

Note that the mixed in class can be referenced using `this` instead. It's also worth noting that using instance fields
in a category class is inherently unsafe: categories are not stateful (like traits).

[[xform-IndexedProperty]]
===== @groovy.transform.IndexedProperty

The `@IndexedProperty` annotation aims at generating indexed getters/setters for properties of list/array types.
This is in particular useful if you want to use a Groovy class from Java. While Groovy supports GPath to access properties,
this is not available from Java. The `@IndexedProperty` annotation will generate indexed properties of the following
form:

[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=indexedproperty_simple,indent=0]
----

[[xform-Lazy]]
===== @groovy.lang.Lazy

The `@Lazy` AST transformation implements lazy initialization of fields. For example, the following code:

[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=lazy_simple,indent=0]
----

will produce the following code:

[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=lazy_simple_generated,indent=0]
----

The default value which is used to initialize the field is the default constructor of the declaration type. It is possible
to define a default value by using a closure on the right hand side of the property assignement, as in the following
example:

----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=lazy_default,indent=0]
----

In that case, the generated code looks like the following:

----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=lazy_default_generated,indent=0]
----

If the field is declared volatile then initialization will be synchronized using the
http://en.wikipedia.org/wiki/Double-checked_locking[double-checked locking] pattern.

Using the `soft=true` parameter, the helper field will use a `SoftReference` instead, providing a simple way to
implement caching. In that case, if the garbage collector decides to collect the reference, initialization will occur
the next time the field is accessed.

[[xform-Newify]]
===== @groovy.lang.Newify

The `@Newify` AST transformation is used to bring alternative syntaxes to construct objects:

* Using the `Python` style:
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=newify_python,indent=0]
----
* or using the `Ruby` style:
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=newify_ruby,indent=0]
----
The `Ruby` version can be disabled by setting the `auto` flag to `false`.

==== Class design annotations

This category of annotations are aimed at simplifying the implementation of well-known design patterns (delegation,
singleton, ...) by using a declarative style.

[[xform-Delegate]]
===== @groovy.lang.Delegate

The `@Delegate` AST transformation aims at implementing the delegation design pattern. In the following class:

[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=delegating_class,indent=0]
----

The `when` field is annotated with `@Delegate`, meaning that the `Event` class will delegate calls to `Date` methods
to the `when` field. In this case, the generated code looks like this:

[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=delegating_class_generated,indent=0]
----

Then you can call the `before` method, for example, directly on the `Event` class:

[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=delegation_assert,indent=0]
----

The behavior of the `@Delegate` AST transformation can be changed using the following parameters:

[cols="1,1,2,3a",options="header"]
|=======================================================================
|Attribute|Default value|Description|Example
|interfaces|True|Should the interfaces implemented by the field be implemented by the class too|
[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=delegate_example_interfaces,indent=0]
----
|deprecated|false|If true, also delegates methods annotated with @Deprecated|
[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=delegate_deprecated_header,indent=0]
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=delegate_deprecated_footer,indent=0]
----
|methodAnnotations|False|Whether to carry over annotations from the methods of the delegate to your delegating method.|
[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=delegate_example_annotations,indent=0]
----
|parameterAnnotations|False|Whether to carry over annotations from the method parameters of the delegate to your delegating method.|
[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=delegate_example_parameter_annotations,indent=0]
----
|excludes|Empty array|A list of methods to be excluded from delegation|
[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=delegate_example_excludes_header,indent=0]
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=delegate_example_excludes_footer,indent=0]
----
|includes|Empty array|A list of methods to be included in delegation|
[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=delegate_example_includes_header,indent=0]
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=delegate_example_includes_footer,indent=0]
----
|=======================================================================

[[xform-Immutable]]
===== @groovy.transform.Immutable

The `@Immutable` AST transformation simplifies the creation of immutable classes, that is to say classes for which
members are deemed immutable. For that, all you have to do is annotating the class like in the following example:

[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=immutable_simple,indent=0]
----

Immutable classes generated with `@Immutable` are automatically made final. For a class to be immutable, you have to
make sure that properties are of an immutable type (primitive or boxed types), of a known-immutable type or another
class annotated with `@Immutable`. The effect of applying `@Immutable` to a class are pretty similar to those of
applying the <<xform-Canonical,@Canonical>> AST transformation, but with an immutable class: automatic generation of
`toString`, `equals` and `hashCode` methods for example, but trying to modify a property would throw a `ReadOnlyPropertyException`
in that case.

Since `@Immutable` relies on a predefined list of known immutable classes (like `java.net.URI` or `java.lang.String`
and fails if you use a type which is not in that list, you are allowed to instruct the transformation that some types
are deemed immutable thanks to the following parameters:

[cols="1,1,2,3a",options="header"]
|=======================================================================
|Attribute|Default value|Description|Example
|knownImmutableClasses|Empty list|A list of classes which are deemed immutable.|
[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=immutable_example_knownimmutableclasses,indent=0]
----
|knownImmutables|Empty list|A list of property names which are deemed immutable.|
[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=immutable_example_knownimmutables,indent=0]
----
----
|copyWith|false|A boolean whether to generate a `copyWith( Map )` method.|
[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=immutable_example_copyWith,indent=0]
----
|=======================================================================

[[xform-Memoized]]
===== @groovy.transform.Memoized

The `@Memoized` AST transformations simplifies the implementation of caching by allowing the result of method calls
to be cached just by annotating the method with `@Memoized`. Let's imagine the following method:

[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=memoized_long_computation,indent=0]
----

This emulates a long computation, based on the actual parameters of the method. Without `@Memoized`, each method call
would take several seconds plus it would return a random result:

[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=memoized_long_computation_asserts,indent=0]
----

Adding `@Memoized` changes the semantics of the method by adding caching, based on the parameters:

[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=memoized_long_computation_cached,indent=0]
----

The size of the cache can be configured using two optional parameters:

* _protectedCacheSize_: the number of results which are guaranteed not to be cleared after garbage collection
* _maxCacheSize_: the maximum number of results that can be kept in memory

By default, the size of the cache is unlimited and no cache result is protected from garbage collection. Setting a
_protectedCacheSize>0_ would create an unlimited cache with some results protected. Setting _maxCacheSize>0_ would
 create a limited cache but without any protection from garbage protection. Setting both would create a limited,
 protected cache.

[[xform-Singleton]]
===== @groovy.lang.Singleton

The `@Singleton` annotation can be used to implement the singleton design pattern on a class. The singleton instance
is defined eagerly by default, using class initialization, or lazily, in which case the field is initialized using
double checked locking.

[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=singleton_simple,indent=0]
----

By default, the singleton is created eagerly when the class is initialized and available through the `instance` property.
It is possible to change the name of the singleton using the `property` parameter:

[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=singleton_example_property,indent=0]
----

And it is also possible to make initialization lazy using the `lazy` parameter:

[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=singleton_example_lazy,indent=0]
----

[[xform-Mixin]]
===== @groovy.transform.Mixin

==== Logging improvements

Groovy provides AST transformation that helps integrating with the most widely used logging frameworks. It's worth noting
that annotating a class with one of those annotations doesn't prevent you from adding the appropriate logging framework
on classpath.

All transformations work in a similar way:

* add static final `log` field corresponding to the logger
* wrap all calls to `log.level()` into the appropriate `log.isLevelEnabled` guard, depending on the underlying framework

Those transformations support two parameters:

* `value` (default `log`) corresponds to the name of the logger field
* `category` (defaults to the class name) is the name of the logger category

[[xform-Log]]
===== @groovy.util.logging.Log

The first logging AST transformation available is the `@Log` annotation which relies on the JDK logging framework. Writing:

[source,groovy]
----
include::{projectdir}/src/spec/test/LogImprovementsASTTransformsTest.groovy[tags=log_spec,indent=0]
----

is equivalent to writing:

[source,groovy]
----
include::{projectdir}/src/spec/test/LogImprovementsASTTransformsTest.groovy[tags=log_equiv,indent=0]
----

[[xform-Commons]]
===== @groovy.util.logging.Commons

Groovy supports the http://commons.apache.org/proper/commons-logging/[Apache Commons Logging] framework using to the
`@Commons` annotation. Writing:

[source,groovy]
----
include::{projectdir}/src/spec/test/LogImprovementsASTTransformsTest.groovy[tags=commons_spec,indent=0]
----

is equivalent to writing:

[source,groovy]
----
include::{projectdir}/src/spec/test/LogImprovementsASTTransformsTest.groovy[tags=commons_equiv,indent=0]
----

[[xform-Log4j]]
===== @groovy.util.logging.Log4j

Groovy supports the http://logging.apache.org/log4j/1.2/[Apache Log4j 1.x] framework using to the
`@Log4j` annotation. Writing:

[source,groovy]
----
include::{projectdir}/src/spec/test/LogImprovementsASTTransformsTest.groovy[tags=log4j_spec,indent=0]
----

is equivalent to writing:

[source,groovy]
----
include::{projectdir}/src/spec/test/LogImprovementsASTTransformsTest.groovy[tags=log4j_equiv,indent=0]
----

[[xform-Log4j2]]
===== @groovy.util.logging.Log4j2

Groovy supports the http://logging.apache.org/log4j/2.x/[Apache Log4j 2.x] framework using to the
`@Log4j2` annotation. Writing:

[source,groovy]
----
include::{projectdir}/src/spec/test/LogImprovementsASTTransformsTest.groovy[tags=log4j2_spec,indent=0]
----

is equivalent to writing:

[source,groovy]
----
include::{projectdir}/src/spec/test/LogImprovementsASTTransformsTest.groovy[tags=log4j2_equiv,indent=0]
----

[[xform-Slf4j]]
===== @groovy.util.logging.Slf4j

Groovy supports the http://www.slf4j.org/[Simple Logging Facade for Java (SLF4J)] framework using to the
`@Slf4j` annotation. Writing:

[source,groovy]
----
include::{projectdir}/src/spec/test/LogImprovementsASTTransformsTest.groovy[tags=slf4j_spec,indent=0]
----

is equivalent to writing:

[source,groovy]
----
include::{projectdir}/src/spec/test/LogImprovementsASTTransformsTest.groovy[tags=slf4j_equiv,indent=0]
----

==== Declarative concurrency

The Groovy language provides a set of annotations aimed at simplifying common concurrency patterns in a declarative
approach.

[[xform-Synchronized]]
===== @groovy.transform.Synchronized

The `@Synchronized` AST transformations works in a similar way to the `synchronized` keyword but locks on different
objects for safer concurrency. It can be applied on any method or static method:

[source,groovy]
----
include::{projectdir}/src/spec/test/DeclarativeConcurrencyASTTransformsTest.groovy[tags=example_synchronized,indent=0]
----

Writing this is equivalent to creating a lock object and wrapping the whole method into a synchronized block:

[source,groovy]
----
include::{projectdir}/src/spec/test/DeclarativeConcurrencyASTTransformsTest.groovy[tags=example_synchronized_equiv,indent=0]
----

By default, `@Synchronized` creates a field named `$lock` (or `$LOCK` for a static method) but you can make it use any
field you want by specifying the value attribute, like in the following example:

[source,groovy]
----
include::{projectdir}/src/spec/test/DeclarativeConcurrencyASTTransformsTest.groovy[tags=example_synchronized_customlock,indent=0]
----

[[xform-WithReadLock]]
===== @groovy.transform.WithReadLock and @groovy.transform.WithWriteLock

The `@WithReadLock` AST transformation works in conjunction with the `@WithWriteLock` transformation
to provide read/write synchronization using the `ReentrantReadWriteLock` facility that the JDK provides. The annotation
can be added to a method or a static method. It will transparently create a `$reentrantLock` final field (or
`$REENTRANTLOCK` for a static method) and proper synchronization code will be added. For example, the following code:

[source,groovy]
----
include::{projectdir}/src/spec/test/DeclarativeConcurrencyASTTransformsTest.groovy[tags=example_rwlock,indent=0]
----

is equivalent to this:

[source,groovy]
----
include::{projectdir}/src/spec/test/DeclarativeConcurrencyASTTransformsTest.groovy[tags=example_rwlock_equiv,indent=0]
----

Both `@WithReadLock` and `@WithWriteLock` support specifying an alternative lock object. In that case, the referenced
 field must be declared by the user, like in the following alternative:

[source,groovy]
----
include::{projectdir}/src/spec/test/DeclarativeConcurrencyASTTransformsTest.groovy[tags=example_rwlock_alter,indent=0]
----

==== Easier cloning and externalizing

Groovy provides two annotations aimed at facilitating the implementation of `Clonable` and `Externalizable` interfaces,
respectively named `@AutoClone` and `@AutoExternalize`.

[[xform-AutoClone]]
===== @groovy.transform.AutoClone

[[xform-AutoExternalize]]
===== @groovy.transform.AutoExternalize

==== Safer scripting
[[xform-ConditionalInterrupt]]
===== @groovy.transform.ConditionalInterrupt

[[xform-ThreadInterrupt]]
===== @groovy.transform.ThreadInterrupt

[[xform-TimedInterrupt]]
===== @groovy.transform.TimedInterrupt

==== Compiler directives
[[xform-Field]]
===== @groovy.transform.Field

[[xform-PackageScope]]
===== @groovy.transform.PackageScope

[[xform-AnnotationCollector]]
===== @groovy.transform.AnnotationCollector

[[xform-DelegatesTo]]
===== @groovy.lang.DelegatesTo

[[xform-TypeChecked]]
===== @groovy.transform.TypeChecked

[[xform-CompileStatic]]
===== @groovy.transform.CompileStatic

[[xform-CompileDynamic]]
===== @groovy.transform.CompileDynamic

==== Swing patterns
[[xform-Bindable]]
===== @groovy.beans.Bindable
[[xform-ListenerList]]
===== @groovy.beans.ListenerList

[[xform-Vetoable]]
===== @groovy.beans.Vetoable


==== Test assistance
[[xform-NotYetImplemented]]
===== @groovy.lang.NotYetImplemented

[[xform-ASTTest]]
===== @groovy.transform.ASTTest

==== Grape handling
[[xform-Grab]]
===== @groovy.lang.Grab
[[xform-GrabConfig]]
===== @groovy.lang.GrabConfig
[[xform-GrabExclude]]
===== @groovy.lang.GrabExclude
[[xform-GrabResolver]]
===== @groovy.lang.GrabResolver
[[xform-Grapes]]
===== @groovy.lang.Grapes

[[developing-ast-xforms]]
=== Developing AST transformations
==== Compilation phases guide
==== Local transformations
==== Global transformations
==== AST API guide
==== Testing AST transformations
