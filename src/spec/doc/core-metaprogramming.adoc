= Metaprogramming

The Groovy language supports two flavors of metaprogramming: runtime metaprogramming and compile-time metaprogramming.
The first one allows altering the class model and the behavior of a program at runtime, while the second only occurs
at compile-time. Both have pros and cons, that we will detail in this section.

== Runtime metaprogramming

=== GroovyObject interface
==== invokeMethod
==== get/setProperty
==== get/setMetaClass

=== get/setAttribute
=== propertyMissing
=== methodMissing
=== GroovyInterceptable
=== Categories

=== Metaclasses
==== Custom metaclasses
===== Delegating metaclass
===== Magic package
==== Per instance metaclass
==== ExpandoMetaClass
===== Constructors
===== Borrowing methods
===== Dynamic method names
===== GroovyObject methods
===== Overriding static invokeMethod
===== Properties
===== Runtime discovery
===== Static methods

=== Extension modules
==== Module descriptor
==== Instance methods
==== Static methods

== Compile-time metaprogramming

Compile-time metaprogramming in Groovy allows code generation at compile-time. Those transformations are altering the
Abstract Syntax Tree (AST) of a program, which is why in Groovy we call it AST transformations. AST transformations
allow you to hook into the compilation process, modify the AST and continue the compilation process to generate regular
bytecode. Compared to runtime metaprogramming, this has the advantage of making the changes visible in the class file
itself (that is to say, in the bytecode). Making it visible in the bytecode is important for example if you want the
transformations to be part of the class contract (implementing interfaces, extending abstract classes, ...) or even
if you need your class to be callable from Java (or other JVM languages). For example, an AST transformation can add
methods to a class. If you do it with runtime metaprogramming, the new method would only be visible from Groovy. If you
do the same using compile-time metaprogramming, the method would be visible from Java too. Last but not least, performance
would likely be better with compile-time metaprogramming (because no initialization phase is required).

In this section, we will start with explaining the various compile-time transformations that are bundled with the Groovy
distribution. In a second time, we will describe how you can <<developing-ast-xforms,implement your own AST transformations>>
and what are the disadvantages of this technique.

=== Available AST transformations

Groovy comes with various AST transformations covering different needs: reducing boilerplate (code generation), implementing
design patterns (delegation, ...), logging, declarative concurrency, cloning, safer scripting, tweaking the compilation,
implementing Swing patterns, testing and eventually managing dependencies. If none of those AST transformations cover
your needs, you can still implement your own, as show in section <<developing-ast-xforms,Developping your own AST
transformations>>.

AST transformations can be separated into two categories:

* global AST transformations are applied transparently, globally, as soon as they are found on compile classpath
* local AST transformations are applied by annotating the source code with markers. Unlike global AST transformations,
local AST transformations may support parameters.

Groovy doesn't ship with any global AST transformation, but you can find a list of local AST transformations
available for you to use in your code here:

==== Code generation transformations

This category of transformation includes AST transformations which helps removing boilerplate code. This is typically
code that you have to write but that does not carry any useful information.

[[xform-ToString]]
===== @groovy.transform.ToString
The `@ToString` AST transformation generates a human readable `toString` representation of the class. For example,
annotating the `Person` class like below will automatically generate the `toString` method for you:

[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tostring_import,indent=0]

include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tostring_simple,indent=0]
----

With this definition, then the following assertion passes, meaning that a `toString` method taking the field valuess from
the class and printing them out has been generated:

[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tostring_simple_assert,indent=0]
----

The `@ToString` annotation accepts several parameters which are summarized in the following table:

[cols="1,1,2,3a",options="header"]
|=======================================================================
|Attribute|Default value|Description|Example
|includeNames|false|Whether to include names of properties in generated toString.|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tostring_example_includeNames,indent=0]
----
|excludes|Empty list|List of properties to exclude from toString|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tostring_example_excludes,indent=0]
----
|includes|Empty list|List of fields to include in toString|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tostring_example_includes,indent=0]
----
|includeSuper|False|Should superclass be included in toString|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tostring_example_includeSuper,indent=0]
----
|includeFields|False|Should fields be included in toString, in addition to properties|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tostring_example_includeFields,indent=0]
----
|ignoreNulls|False|Should properties/fields with null value be displayed|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tostring_example_ignoreNulls,indent=0]
----
|includePackage|False|Use fully qualified class name instead of simple name in toString|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tostring_example_includePackage,indent=0]
----
|cache|False|Cache the toString string. Should only be set to true if the class is immutable.|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tostring_example_cache,indent=0]
----

|=======================================================================

[[xform-EqualsAndHashCode]]
===== @groovy.transform.EqualsAndHashCode

The `@EqualsAndHashCode` AST transformation aims at generating `equals` and `hashCode` methods for you. The generated
hashcode follows the best practices as described in _Effective Java_ by _Josh Bloch_:

[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=equalshashcode,indent=0]
----

There are several options available to tweak the behavior of `@EqualsAndHashCode`:

[cols="1,1,2,3a",options="header"]
|=======================================================================
|Attribute|Default value|Description|Example
|excludes|Empty list|List of properties to exclude from equals/hashCode|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=equalshashcode_example_excludes,indent=0]
----
|includes|Empty list|List of fields to include in equals/hashCode|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=equalshashcode_example_includes,indent=0]
----
|callSuper|False|Whether to include super in equals and hashCode calculations|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=equalshashcode_example_super,indent=0]
----
|includeFields|False|Should fields be included in equals/hashCode, in addition to properties|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tostring_example_includeFields,indent=0]
----
|cache|False|Cache the hashCode computation. Should only be set to true if the class is immutable.|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tostring_example_cache,indent=0]
----
|useCanEqual|True|Should equals call canEqual helper method.|See http://www.artima.com/lejava/articles/equality.html
|=======================================================================

[[xform-TupleConstructor]]
===== @groovy.transform.TupleConstructor

The `@TupleConstructor` annotation aims at eliminating boilerplate code by generating constructors for you. A tuple
constructor is created for each property, with default values (using the Java default values). For example, the
following code will generate 3 constructors:

[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tupleconstructor_simple,indent=0]
----

The first constructor is a no-arg constructor which allows the traditional map-style construction. It is worth noting
that if the first property (or field) has type LinkedHashMap or if there is a single Map, AbstractMap or HashMap
property (or field), then the map-style mapping is not available.

The other constructors are generated by taking the properties in the order they are defined. Groovy will generate as
many constructors as they are properties (or fields, depending on the options).

The `@TupleConstructor` AST transformation accepts several configuration options:

[cols="1,1,2,3a",options="header"]
|=======================================================================
|Attribute|Default value|Description|Example
|excludes|Empty list|List of properties to exclude from tuple constructor generation|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tupleconstructor_example_excludes,indent=0]
----
|includes|Empty list|List of fields to include in tuple constructor generation|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tupleconstructor_example_includes,indent=0]
----
|includeFields|False|Should fields be included in tuple constructor generation, in addition to properties|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tupleconstructor_example_includeFields,indent=0]
----
|includeProperties|True|Should properties be included in tuple constructor generation|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tupleconstructor_example_includeProperties,indent=0]
----
|includeSuperFields|False|Should fields from super classes be included in tuple constructor generation|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tupleconstructor_example_includeSuperFields,indent=0]
----
|includeSuperProperties|True|Should properties from super classes be included in tuple constructor generation|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tupleconstructor_example_includeSuperProperties,indent=0]
----
|callSuper|False|Should super properties be called within a call to the parent constructor rather than set as properties|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tupleconstructor_example_callSuper,indent=0]
----
|force|False|By default, the transformation will do nothing if a constructor is already defined. Setting this property
to true, the constructor will be generated and it's your responsability to ensure that no duplicate constructor
is defined|See javadocs
|=======================================================================

[[xform-Canonical]]
===== @groovy.transform.Canonical

The `@Canonical` AST transformation combines the effects of the <<xform-ToString,@ToString>>,
<<xform-EqualsAndHashCode,@EqualsAndHashCode>> and <<xform-TupleConstructor,@TupleConstructor>>
annotations:

[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=canonical_simple,indent=0]
----

A similar immutable class can be generated using the <<xform-Immutable,@Immutable>> AST transformation instead.
The `@Canonical` AST transformation supports several configuration options:

[cols="1,1,2,3a",options="header"]
|=======================================================================
|Attribute|Default value|Description|Example
|excludes|Empty list|List of properties to exclude from tuple constructor generation|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=canonical_example_excludes,indent=0]
----
|includes|Empty list|List of fields to include in tuple constructor generation|
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=canonical_example_includes,indent=0]
----
|=======================================================================

[[xform-InheritConstructors]]
===== @groovy.transform.InheritConstructors

The `@InheritConstructor` AST transformation aims at generating constructors matching super constructors for you. This
is in particular useful when overridding exception classes:

[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=inheritconstructors_simple,indent=0]
----

[[xform-Category]]
===== @groovy.lang.Category

The `@Category` AST transformation simplifies the creation of Groovy categories. Historically, a Groovy category was
written like this:

[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=oldstyle_category,indent=0]
----

The `@Category` transformation lets you write the same using an instance-style class, rather that a static class style.
This removes the need for having the first argument of each method being the receiver. The category can be written like
this:

[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=newstyle_category,indent=0]
----

Note that the mixed in class can be referenced using `this` instead. It's also worth noting that using instance fields
in a category class is inherently unsafe: categories are not stateful (like traits).

[[xform-IndexedProperty]]
===== @groovy.transform.IndexedProperty

The `@IndexedProperty` annotation aims at generating indexed getters/setters for properties of list/array types.
This is in particular useful if you want to use a Groovy class from Java. While Groovy supports GPath to access properties,
this is not available from Java. The `@IndexedProperty` annotation will generate indexed properties of the following
form:

[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=indexedproperty_simple,indent=0]
----

[[xform-Lazy]]
===== @groovy.lang.Lazy

The `@Lazy` AST transformation implements lazy initialization of fields. For example, the following code:

[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=lazy_simple,indent=0]
----

will produce the following code:

[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=lazy_simple_generated,indent=0]
----

The default value which is used to initialize the field is the default constructor of the declaration type. It is possible
to define a default value by using a closure on the right hand side of the property assignement, as in the following
example:

----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=lazy_default,indent=0]
----

In that case, the generated code looks like the following:

----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=lazy_default_generated,indent=0]
----

If the field is declared volatile then initialization will be synchronized using the
http://en.wikipedia.org/wiki/Double-checked_locking[double-checked locking] pattern.

Using the `soft=true` parameter, the helper field will use a `SoftReference` instead, providing a simple way to
implement caching. In that case, if the garbage collector decides to collect the reference, initialization will occur
the next time the field is accessed.

[[xform-Newify]]
===== @groovy.lang.Newify

The `@Newify` AST transformation is used to bring alternative syntaxes to construct objects:

* Using the `Python` style:
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=newify_python,indent=0]
----
* or using the `Ruby` style:
[source,groovy]
----
include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=newify_ruby,indent=0]
----
The `Ruby` version can be disabled by setting the `auto` flag to `false`.

==== Class design annotations

This category of annotations are aimed at simplifying the implementation of well-known design patterns (delegation,
singleton, ...) by using a declarative style.

[[xform-Delegate]]
===== @groovy.lang.Delegate

The `@Delegate` AST transformation aims at implementing the delegation design pattern. In the following class:

[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=delegating_class,indent=0]
----

The `when` field is annotated with `@Delegate`, meaning that the `Event` class will delegate calls to `Date` methods
to the `when` field. In this case, the generated code looks like this:

[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=delegating_class_generated,indent=0]
----

Then you can call the `before` method, for example, directly on the `Event` class:

[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=delegation_assert,indent=0]
----

The behavior of the `@Delegate` AST transformation can be changed using the following parameters:

[cols="1,1,2,3a",options="header"]
|=======================================================================
|Attribute|Default value|Description|Example
|interfaces|True|Should the interfaces implemented by the field be implemented by the class too|
[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=delegate_example_interfaces,indent=0]
----
|deprecated|false|If true, also delegates methods annotated with @Deprecated|
[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=delegate_deprecated_header,indent=0]
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=delegate_deprecated_footer,indent=0]
----
|methodAnnotations|False|Whether to carry over annotations from the methods of the delegate to your delegating method.|
[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=delegate_example_annotations,indent=0]
----
|parameterAnnotations|False|Whether to carry over annotations from the method parameters of the delegate to your delegating method.|
[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=delegate_example_parameter_annotations,indent=0]
----
|excludes|Empty array|A list of methods to be excluded from delegation|
[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=delegate_example_excludes_header,indent=0]
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=delegate_example_excludes_footer,indent=0]
----
|includes|Empty array|A list of methods to be included in delegation|
[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=delegate_example_includes_header,indent=0]
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=delegate_example_includes_footer,indent=0]
----
|=======================================================================

[[xform-Immutable]]
===== @groovy.transform.Immutable

The `@Immutable` AST transformation simplifies the creation of immutable classes, that is to say classes for which
members are deemed immutable. For that, all you have to do is annotating the class like in the following example:

[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=immutable_simple,indent=0]
----

Immutable classes generated with `@Immutable` are automatically made final. For a class to be immutable, you have to
make sure that properties are of an immutable type (primitive or boxed types), of a known-immutable type or another
class annotated with `@Immutable`. The effect of applying `@Immutable` to a class are pretty similar to those of
applying the <<xform-Canonical,@Canonical>> AST transformation, but with an immutable class: automatic generation of
`toString`, `equals` and `hashCode` methods for example, but trying to modify a property would throw a `ReadOnlyPropertyException`
in that case.

Since `@Immutable` relies on a predefined list of known immutable classes (like `java.net.URI` or `java.lang.String`
and fails if you use a type which is not in that list, you are allowed to instruct the transformation that some types
are deemed immutable thanks to the following parameters:

[cols="1,1,2,3a",options="header"]
|=======================================================================
|Attribute|Default value|Description|Example
|knownImmutableClasses|Empty list|A list of classes which are deemed immutable.|
[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=immutable_example_knownimmutableclasses,indent=0]
----
|knownImmutables|Empty list|A list of property names which are deemed immutable.|
[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=immutable_example_knownimmutables,indent=0]
----
|=======================================================================

[[xform-Memoized]]
===== @groovy.transform.Memoized

The `@Memoized` AST transformations simplifies the implementation of caching by allowing the result of method calls
to be cached just by annotating the method with `@Memoized`. Let's imagine the following method:

[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=memoized_long_computation,indent=0]
----

This emulates a long computation, based on the actual parameters of the method. Without `@Memoized`, each method call
would take several seconds plus it would return a random result:

[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=memoized_long_computation_asserts,indent=0]
----

Adding `@Memoized` changes the semantics of the method by adding caching, based on the parameters:

[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=memoized_long_computation_cached,indent=0]
----

The size of the cache can be configured using two optional parameters:

* _protectedCacheSize_: the number of results which are guaranteed not to be cleared after garbage collection
* _maxCacheSize_: the maximum number of results that can be kept in memory

By default, the size of the cache is unlimited and no cache result is protected from garbage collection. Setting a
_protectedCacheSize>0_ would create an unlimited cache with some results protected. Setting _maxCacheSize>0_ would
 create a limited cache but without any protection from garbage protection. Setting both would create a limited,
 protected cache.

[[xform-Singleton]]
===== @groovy.lang.Singleton

The `@Singleton` annotation can be used to implement the singleton design pattern on a class. The singleton instance
is defined eagerly by default, using class initialization, or lazily, in which case the field is initialized using
double checked locking.

[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=singleton_simple,indent=0]
----

By default, the singleton is created eagerly when the class is initialized and available through the `instance` property.
It is possible to change the name of the singleton using the `property` parameter:

[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=singleton_example_property,indent=0]
----

And it is also possible to make initialization lazy using the `lazy` parameter:

[source,groovy]
----
include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=singleton_example_lazy,indent=0]
----

[[xform-Mixin]]
===== @groovy.transform.Mixin

==== Logging improvements

Groovy provides AST transformation that helps integrating with the most widely used logging frameworks. It's worth noting
that annotating a class with one of those annotations doesn't prevent you from adding the appropriate logging framework
on classpath.

All transformations work in a similar way:

* add static final `log` field corresponding to the logger
* wrap all calls to `log.level()` into the appropriate `log.isLevelEnabled` guard, depending on the underlying framework

Those transformations support two parameters:

* `value` (default `log`) corresponds to the name of the logger field
* `category` (defaults to the class name) is the name of the logger category

[[xform-Log]]
===== @groovy.util.logging.Log

The first logging AST transformation available is the `@Log` annotation which relies on the JDK logging framework. Writing:

[source,groovy]
----
include::{projectdir}/src/spec/test/LogImprovementsASTTransformsTest.groovy[tags=log_spec,indent=0]
----

is equivalent to writing:

[source,groovy]
----
include::{projectdir}/src/spec/test/LogImprovementsASTTransformsTest.groovy[tags=log_equiv,indent=0]
----

[[xform-Commons]]
===== @groovy.util.logging.Commons

Groovy supports the http://commons.apache.org/proper/commons-logging/[Apache Commons Logging] framework using to the
`@Commons` annotation. Writing:

[source,groovy]
----
include::{projectdir}/src/spec/test/LogImprovementsASTTransformsTest.groovy[tags=commons_spec,indent=0]
----

is equivalent to writing:

[source,groovy]
----
include::{projectdir}/src/spec/test/LogImprovementsASTTransformsTest.groovy[tags=commons_equiv,indent=0]
----

[[xform-Log4j]]
===== @groovy.util.logging.Log4j

Groovy supports the http://logging.apache.org/log4j/1.2/[Apache Log4j 1.x] framework using to the
`@Log4j` annotation. Writing:

[source,groovy]
----
include::{projectdir}/src/spec/test/LogImprovementsASTTransformsTest.groovy[tags=log4j_spec,indent=0]
----

is equivalent to writing:

[source,groovy]
----
include::{projectdir}/src/spec/test/LogImprovementsASTTransformsTest.groovy[tags=log4j_equiv,indent=0]
----

[[xform-Log4j2]]
===== @groovy.util.logging.Log4j2

Groovy supports the http://logging.apache.org/log4j/2.x/[Apache Log4j 2.x] framework using to the
`@Log4j2` annotation. Writing:

[source,groovy]
----
include::{projectdir}/src/spec/test/LogImprovementsASTTransformsTest.groovy[tags=log4j2_spec,indent=0]
----

is equivalent to writing:

[source,groovy]
----
include::{projectdir}/src/spec/test/LogImprovementsASTTransformsTest.groovy[tags=log4j2_equiv,indent=0]
----

[[xform-Slf4j]]
===== @groovy.util.logging.Slf4j

Groovy supports the http://www.slf4j.org/[Simple Logging Facade for Java (SLF4J)] framework using to the
`@Slf4j` annotation. Writing:

[source,groovy]
----
include::{projectdir}/src/spec/test/LogImprovementsASTTransformsTest.groovy[tags=slf4j_spec,indent=0]
----

is equivalent to writing:

[source,groovy]
----
include::{projectdir}/src/spec/test/LogImprovementsASTTransformsTest.groovy[tags=slf4j_equiv,indent=0]
----

==== Declarative concurrency

The Groovy language provides a set of annotations aimed at simplifying common concurrency patterns in a declarative
approach.

[[xform-Synchronized]]
===== @groovy.transform.Synchronized

The `@Synchronized` AST transformations works in a similar way to the `synchronized` keyword but locks on different
objects for safer concurrency. It can be applied on any method or static method:

[source,groovy]
----
include::{projectdir}/src/spec/test/DeclarativeConcurrencyASTTransformsTest.groovy[tags=example_synchronized,indent=0]
----

Writing this is equivalent to creating a lock object and wrapping the whole method into a synchronized block:

[source,groovy]
----
include::{projectdir}/src/spec/test/DeclarativeConcurrencyASTTransformsTest.groovy[tags=example_synchronized_equiv,indent=0]
----

By default, `@Synchronized` creates a field named `$lock` (or `$LOCK` for a static method) but you can make it use any
field you want by specifying the value attribute, like in the following example:

[source,groovy]
----
include::{projectdir}/src/spec/test/DeclarativeConcurrencyASTTransformsTest.groovy[tags=example_synchronized_customlock,indent=0]
----

[[xform-WithReadLock]]
===== @groovy.transform.WithReadLock and @groovy.transform.WithWriteLock

The `@WithReadLock` AST transformation works in conjunction with the `@WithWriteLock` transformation
to provide read/write synchronization using the `ReentrantReadWriteLock` facility that the JDK provides. The annotation
can be added to a method or a static method. It will transparently create a `$reentrantLock` final field (or
`$REENTRANTLOCK` for a static method) and proper synchronization code will be added. For example, the following code:

[source,groovy]
----
include::{projectdir}/src/spec/test/DeclarativeConcurrencyASTTransformsTest.groovy[tags=example_rwlock,indent=0]
----

is equivalent to this:

[source,groovy]
----
include::{projectdir}/src/spec/test/DeclarativeConcurrencyASTTransformsTest.groovy[tags=example_rwlock_equiv,indent=0]
----

Both `@WithReadLock` and `@WithWriteLock` support specifying an alternative lock object. In that case, the referenced
 field must be declared by the user, like in the following alternative:

[source,groovy]
----
include::{projectdir}/src/spec/test/DeclarativeConcurrencyASTTransformsTest.groovy[tags=example_rwlock_alter,indent=0]
----

For details

* See Javadoc for gapi::groovy.transform.WithReadLock
* See Javadoc for gapi::groovy.transform.WithWriteLock

==== Easier cloning and externalizing

Groovy provides two annotations aimed at facilitating the implementation of `Clonable` and `Externalizable` interfaces,
respectively named `@AutoClone` and `@AutoExternalize`.

[[xform-AutoClone]]
===== @groovy.transform.AutoClone

The `@AutoClone` annotation is aimed at implementing the `@java.lang.Cloneable` interface using various strategies, thanks to the `style` parameter:

* the default `AutoCloneStyle.CLONE` strategy calls `super.clone()` first then `clone()` on each cloneable property (and
just copies non `Cloneable` properties)
* the `AutoCloneStyle.SIMPLE` strategy uses a regular constructor call and copies properties from the source to the clone
* the `AutoCloneStyle.COPY_CONSTRUCTOR` strategy creates and uses a copy constructor
* the `AutoCloneStyle.SERIALIZATION` strategy uses serialization (or externalization) to clone the object

Each of those strategies have pros and cons which are discussed in the Javadoc for gapi::groovy.transform.AutoClone and gapi::groovy.transform.AutoCloneStyle .

For example, the following example:

[source,groovy]
----
include::{projectdir}/src/spec/test/CloningASTTransformsTest.groovy[tags=example_autoclone,indent=0]
----

is equivalent to this:

[source,groovy]
----
include::{projectdir}/src/spec/test/CloningASTTransformsTest.groovy[tags=example_autoclone_equiv,indent=0]
----

In addition to cloning styles, `@AutoClone` supports multiple options:

[cols="1,1,2,3a",options="header"]
|=======================================================================
|Attribute|Default value|Description|Example
|excludes|Empty list|A list of property or field names that need to be excluded from cloning. A string consisting of a comma-separated field/property names is also allowed.
See gapi::groovy.transform.AutoClone#excludes for details|
[source,groovy]
----
include::{projectdir}/src/spec/test/CloningASTTransformsTest.groovy[tags=example_autoclone_excludes,indent=0]
----
|includeFields|false|By default, only properties are cloned. Setting this flag to true will also clone fields.|
[source,groovy]
----
include::{projectdir}/src/spec/test/CloningASTTransformsTest.groovy[tags=example_autoclone_includeFields,indent=0]
----
|=======================================================================

[[xform-AutoExternalize]]
===== @groovy.transform.AutoExternalize

The `@AutoExternalize` AST transformation will assist in the creation of `java.io.Externalizable` classes. It will
automatically add the interface to the class and generate the `writeExternal` and `readExternal` methods. For example, this
code:

[source,groovy]
----
include::{projectdir}/src/spec/test/CloningASTTransformsTest.groovy[tags=example_autoext,indent=0]
----

will be converted into:

[source,groovy]
----
include::{projectdir}/src/spec/test/CloningASTTransformsTest.groovy[tags=example_autoext_equiv,indent=0]
----

The `@AutoExternalize` annotation supports two parameters which will let you slightly customize its behavior:

[cols="1,1,2,3a",options="header"]
|=======================================================================
|Attribute|Default value|Description|Example
|excludes|Empty list|A list of property or field names that need to be excluded from externalizing. A string consisting of a comma-separated field/property names is also allowed.
See gapi::groovy.transform.AutoExternalize#excludes for details|
[source,groovy]
----
include::{projectdir}/src/spec/test/CloningASTTransformsTest.groovy[tags=example_autoext_excludes,indent=0]
----
|includeFields|false|By default, only properties are externalized. Setting this flag to true will also clone fields.|
[source,groovy]
----
include::{projectdir}/src/spec/test/CloningASTTransformsTest.groovy[tags=example_autoext_includeFields,indent=0]
----
|=======================================================================


==== Safer scripting

The Groovy language makes it easy to execute user scripts at runtime (for example using gapi::groovy.lang.GroovyShell),
but how do you make sure that a script won't eat all CPU (infinite loops) or that concurrent scripts won't slowly consume
all available threads of a thread pool? Groovy provides several annotations which are aimed towards safer scripting,
generating code which will for example allow you to interrupt execution automatically.

[[xform-ThreadInterrupt]]
===== @groovy.transform.ThreadInterrupt

One complicated situation in the JVM world is when a thread can't be stopped. The `Thread#stop` method exists but is
deprecated (and isn't reliable) so your only chance relies in `Thread#interrupt`. Calling the latter will set the
`interrupt` flag on the thread, but it will *not* stop the execution of the thread. This is problematic because it's the
responsability of the code executing in the thread to check the interrupt flag and properly exit. This makes sense when
you, as a developer, know that the code you are executing is meant to be run in an independent thread, but in general,
you don't know it. It's even worse with user scripts, who might not even know what a thread is (think of DSLs).

`@ThreadInterrupt` simplifies this by adding thread interruption checks at critical places in the code:

* loops (for, while)
* first instruction of a method
* first instruction of a closure body

Let's imagine the following user script:

[source,groovy]
----
include::{projectdir}/src/spec/test/SaferScriptingASTTransformsTest.groovy[tags=threadinterrupt_infiniteloop,indent=0]
----

This is an obvious infinite loop. If this code executes in its own thread, interrupting wouldn't help: if you `join` on
the thread, then the calling code would be able to continue, but the thread would still be alive, running in background
without any ability for you to stop it, slowly causing thread starvation.

One possibility to work around this is to setup your shell this way:

[source,groovy]
----
include::{projectdir}/src/spec/test/SaferScriptingASTTransformsTest.groovy[tags=threadinterrupt_shell_setup,indent=0]
----

The shell is then configured to automatically apply the `@ThreadInterrupt` AST transformations on all scripts. This allows
you to execute user scripts this way:

[source,groovy]
----
include::{projectdir}/src/spec/test/SaferScriptingASTTransformsTest.groovy[tags=threadinterrupt_control,indent=0]
----

The transformation automatically modified user code like this:

[source,groovy]
----
include::{projectdir}/src/spec/test/SaferScriptingASTTransformsTest.groovy[tags=threadinterrupt_infiniteloop_equiv,indent=0]
----

The check which is introduced inside the loop guarantees that if the `interrupt` flag is set on the current thread, an
exception will be thrown, interrupting the execution of the thread.

`@ThreadInterrupt` supports multiple options that will let you further customize the behavior of the transformation:

[cols="1,1,2,3a",options="header"]
|=======================================================================
|Attribute|Default value|Description|Example
|thrown|`java.lang.InterruptedException`|Specifies the type of exception which is thrown if the thread is interrupted.|
[source,groovy]
----
include::{projectdir}/src/spec/test/SaferScriptingASTTransformsTest.groovy[tags=threadinterrupt_thrown,indent=0]
----
|checkOnMethodStart|true|Should an interruption check be inserted at the beginning of each method body. See gapi::groovy.transform.ThreadInterrupt for details.|
[source,groovy]
----
@ThreadInterrupt(checkOnMethodStart=false)
----
|applyToAllClasses|true|Should the transformation be applied on all classes of the same source unit (in the same source file). See gapi::groovy.transform.ThreadInterrupt for details.|
[source,groovy]
----
@ThreadInterrupt(applyToAllClasses=false)
class A { ... } // interrupt checks added
class B { ... } // no interrupt checks
----
|applyToAllMembers|true|Should the transformation be applied on all members of class. See gapi::groovy.transform.ThreadInterrupt for details.|
[source,groovy]
----
class A {
    @ThreadInterrupt(applyToAllMembers=false)
    void method1() { ... } // interrupt checked added
    void method2() { ... } // no interrupt checks
}
----
|=======================================================================

[[xform-TimedInterrupt]]
===== @groovy.transform.TimedInterrupt

The `@TimedInterrupt` AST transformation tries to solve a slightly different problem from <<xform-ThreadInterrupt>>: instead of checking the `interrupt` flag of the thread, it will automatically
throw an exception if the thread has been running for too long.

NOTE: This annotation does *not* spawn a monitoring thread. Instead, it works in a similar manner as `@ThreadInterrupt` by placing checks at appropriate places in the code. This means that if you
have a thread blocked by I/O, it will *not* be interrupted.

Imagine the following user code:

[source,groovy]
----
include::{projectdir}/src/spec/test/SaferScriptingASTTransformsTest.groovy[tags=timedinterrupt_fib,indent=0]
----

The implementation of the famous Fibonacci number computation here is far from optimized. If it is called with a high `n` value, it can take minutes to answer. With `@TimedInterrupt`, you can
choose how long a script is allowed to run. The following setup code will allow the user script to run for 1 second at max:

[source,groovy]
----
include::{projectdir}/src/spec/test/SaferScriptingASTTransformsTest.groovy[tags=timedinterrupt_shell_setup,indent=0]
----

This code is equivalent to annotating a class with `@TimedInterrupt` like this:

[source,groovy]
----
@TimedInterrup(value=1, unit=TimeUnit.SECONDS)
class MyClass {
    def fib(int n) {
        n<2?n:fib(n-1)+fib(n-2)
    }
}
----

`@TimedInterrupt` supports multiple options that will let you further customize the behavior of the transformation:

[cols="1,1,2,3a",options="header"]
|=======================================================================
|Attribute|Default value|Description|Example
|value|Long.MAX_VALUE|Used in combination with `unit` to specify after how long execution times out.|
[source,groovy]
----
include::{projectdir}/src/spec/test/SaferScriptingASTTransformsTest.groovy[tags=timedinterrupt_duration,indent=0]
----
|unit|TimeUnit.SECONDS|Used in combination with `value` to specify after how long execution times out.|
[source,groovy]
----
include::{projectdir}/src/spec/test/SaferScriptingASTTransformsTest.groovy[tags=timedinterrupt_duration,indent=0]
----
|thrown|`java.util.concurrent.TimeoutException`|Specifies the type of exception which is thrown if timeout is reached.|
[source,groovy]
----
include::{projectdir}/src/spec/test/SaferScriptingASTTransformsTest.groovy[tags=timedinterrupt_thrown,indent=0]
----
|checkOnMethodStart|true|Should an interruption check be inserted at the beginning of each method body. See gapi::groovy.transform.TimedInterrupt for details.|
[source,groovy]
----
@TimedInterrupt(checkOnMethodStart=false)
----
|applyToAllClasses|true|Should the transformation be applied on all classes of the same source unit (in the same source file). See gapi::groovy.transform.TimedInterrupt for details.|
[source,groovy]
----
@TimedInterrupt(applyToAllClasses=false)
class A { ... } // interrupt checks added
class B { ... } // no interrupt checks
----
|applyToAllMembers|true|Should the transformation be applied on all members of class. See gapi::groovy.transform.TimedInterrupt for details.|
[source,groovy]
----
class A {
    @TimedInterrupt(applyToAllMembers=false)
    void method1() { ... } // interrupt checked added
    void method2() { ... } // no interrupt checks
}
----
|=======================================================================

WARNING: `@TimedInterrupt` is currently not compatible with static methods!

[[xform-ConditionalInterrupt]]
===== @groovy.transform.ConditionalInterrupt

The last annotation for safer scripting is the base annotation when you want to interrupt a script using a custom strategy. In particular, this is the annotation of choice if you
want to use resource management (limit the number of calls to an API, ...). In the following example, user code is using an infinite loop, but `@ConditionalInterrupt` will allow us
to check a quota manager and interrupt automatically the script:

[source,groovy]
----
include::{projectdir}/src/spec/test/SaferScriptingASTTransformsTest.groovy[tags=conditionalinterrupt,indent=0]
----

The quota checking is very basic here, but it can be any code:

[source,groovy]
----
include::{projectdir}/src/spec/test/SaferScriptingASTTransformsTest.groovy[tags=conditionalinterrupt_quotaclass,indent=0]
----

We can make sure `@ConditionalInterrupt` works properly using this test code:

[source,groovy]
----
include::{projectdir}/src/spec/test/SaferScriptingASTTransformsTest.groovy[tags=conditionalinterrupt_assert,indent=0]
----

Of course, in practice, it is unlikely that `@ConditionalInterrupt` will be itself added by hand on user code. It can be injected in a similar manner as the example shown in the
<<xform-ThreadInterrupt,ThreadInterrupt>> section, using the gapi::org.codehaus.groovy.control.customizers.ASTTransformationCustomizer :

[source,groovy]
----
include::{projectdir}/src/spec/test/SaferScriptingASTTransformsTest.groovy[tags=conditionalinterrupt_injected,indent=0]
----

`@ConditionalInterrupt` supports multiple options that will let you further customize the behavior of the transformation:

[cols="1,1,2,3a",options="header"]
|=======================================================================
|Attribute|Default value|Description|Example
|value||The closure which will be called to check if execution is allowed. If the closure returns false, execution is allowed. If it returns true, then an exception will be thrown.|
[source,groovy]
----
@ConditionalInterrupt({ ... })
----
|thrown|`java.lang.InterruptedException`|Specifies the type of exception which is thrown if execution should be aborted.|
[source,groovy]
----
include::{projectdir}/src/spec/test/SaferScriptingASTTransformsTest.groovy[tags=conditionalinterrupt_thrown,indent=0]
----
|checkOnMethodStart|true|Should an interruption check be inserted at the beginning of each method body. See gapi::groovy.transform.ConditionalInterrupt for details.|
[source,groovy]
----
@ConditionalInterrupt(checkOnMethodStart=false)
----
|applyToAllClasses|true|Should the transformation be applied on all classes of the same source unit (in the same source file). See gapi::groovy.transform.ConditionalInterrupt for details.|
[source,groovy]
----
@ConditionalInterrupt(applyToAllClasses=false)
class A { ... } // interrupt checks added
class B { ... } // no interrupt checks
----
|applyToAllMembers|true|Should the transformation be applied on all members of class. See gapi::groovy.transform.ConditionalInterrupt for details.|
[source,groovy]
----
class A {
    @ConditionalInterrupt(applyToAllMembers=false)
    void method1() { ... } // interrupt checked added
    void method2() { ... } // no interrupt checks
}
----
|=======================================================================

==== Compiler directives
[[xform-Field]]
===== @groovy.transform.Field

[[xform-PackageScope]]
===== @groovy.transform.PackageScope

[[xform-AnnotationCollector]]
===== @groovy.transform.AnnotationCollector

[[xform-DelegatesTo]]
===== @groovy.lang.DelegatesTo

[[xform-TypeChecked]]
===== @groovy.transform.TypeChecked

[[xform-CompileStatic]]
===== @groovy.transform.CompileStatic

[[xform-CompileDynamic]]
===== @groovy.transform.CompileDynamic

==== Swing patterns
[[xform-Bindable]]
===== @groovy.beans.Bindable
[[xform-ListenerList]]
===== @groovy.beans.ListenerList

[[xform-Vetoable]]
===== @groovy.beans.Vetoable


==== Test assistance
[[xform-NotYetImplemented]]
===== @groovy.lang.NotYetImplemented

[[xform-ASTTest]]
===== @groovy.transform.ASTTest

==== Grape handling
[[xform-Grab]]
===== @groovy.lang.Grab
[[xform-GrabConfig]]
===== @groovy.lang.GrabConfig
[[xform-GrabExclude]]
===== @groovy.lang.GrabExclude
[[xform-GrabResolver]]
===== @groovy.lang.GrabResolver
[[xform-Grapes]]
===== @groovy.lang.Grapes

[[developing-ast-xforms]]
=== Developing AST transformations
==== Compilation phases guide
==== Local transformations
==== Global transformations
==== AST API guide
==== Testing AST transformations
