= Operators

This chapter covers the operators of the Groovy programming language.

== Arithmetic operators

Groovy supports the usual familiar arithmetic operators you find in mathematics and in other programming languages like Java.
All the Java arithmetic operators are supported. Let's go through them in the following examples.

=== Normal arithmetic operators

The following binary arithmetic operators are available in Groovy:

[cols="1,1,1" options="header"]
|====
| Operator
| Purpose
| Remarks

| +++
| addition
|

| +-+
| substraction
|

| +*+
| multiplication
|

| +/+
| division
| Use +intdiv()+ for integer division, and see the section about <<core-syntax.adoc#integer_division,the integer division>> for more information on the return type of the division.

| +%+
| modulo
|

| +**+
| power
| See the section about <<core-syntax.adoc#power_operator,the power operation>> for more information on the return type of the operation.
|====

Here are a few examples of usage of those operators:

[source,groovy]
----
include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=binary_arith_ops,indent=0]
----

=== Unary operators

The +++ and +-+ operators are also available as unary operators:

[source,groovy]
----
include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=unary_plus_minus,indent=0]
----
<1> Note the usage of parentheses to surround an expression to apply the unary minus to that surrounded expression.

In terms of unary arithmetics operators, the ++++ (increment) and +--+ (decrement) operators are available, 
both in prefix and postfix notation:

[source,groovy]
----
include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=plusplus_minusminus,indent=0]
----
<1> The postfix increment will increment +a+ after the expression has been evaluated and assigned into +b+
<2> The postfix decrement will decrement +c+ after the expression has been evaluated and assigned into +d+
<3> The prefix increment will increment +e+ before the expression is evaluated and assigned into +f+
<4> The prefix decrement will decrement +g+ before the expression is evaluated and assigned into +h+

=== Assignment arithmetic operators

From the binary arithmetic operators we have seen above, certain of them are also available in an assignment form:

* ++=+
* +-=+
* +*=+
* +/=+
* +%=+

Let's see them in action:

[source,groovy]
----
include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=binary_assign_operators,indent=0]
----

== Relational operators

Relational operators allow comparisons between objects, to know if two objects are the same or different,
or if one is greater or lower than or equal to the other.

The following operators are available:

[cols="1,1" options="header"]
|====
| Operator
| Purpose

| +==+
| equal

| +!=+
| different

| +<+
| less than

| `<=`
| less than or equal

| +>+
| greater than

| +>=+
| greater than or equal
|====

These operators into action in simple number comparisons:

[source,groovy]
----
include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=simple_relational_op,indent=0]
----

== Logical operators

Groovy offers three logical operators for boolean expressions:

* `&&`: logical "and"
* `||`: logical "or"
* `!`: logical "not"

Let's illustrate them with the following examples:

[source,groovy]
----
include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=logical_op,indent=0]
----
<1> "not" false is true
<2> true "and" true is true
<3> true "or" false is true

=== Precedence

The logical "not" has a higher priority than the logical "and".

[source,groovy]
----
include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=logical_precendence_1,indent=0]
----
<1> Here, the assertion is true, because "not" has a higher precedence than "and", otherwise, the assertion would have failed

The logical "and" has a higher priority than the logical "or".

[source,groovy]
----
include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=logical_precendence_2,indent=0]
----
<1> Here, the assertion is true, because "and" has a higher precedence than "or", otherwise, the assertion would have failed

=== Short-circuiting for `||`

The logical "or" operator is supporting short-circuiting: if the left operand is true, it won't evaluate the right operand.
The right operand will be evaluated only if the left operand is false.

[source,groovy]
----
include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=logical_or_shortcircuit,indent=0]
----
<1> We create a function that returns its boolean argument, but it sets the `called` flag 
<2> In the first case, we confirm that the function is not called, as `||` short-circuits the evaluation of the right operand.
<3> In the second case, the right operand is called, as indicated by the fact our flag is now true


== Bitwise operators

Groovy offers 4 bitwise operators:

* `&`: bitwise "and"
* `|`: bitwise "or"
* `^`: bitwise "xor" (exclusive "or")
* `~`: bitwise negation

Bitwise operators can be applied on a `byte` or an `int` and return an `int`:

[source,groovy]
----
include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=bitwise_op,indent=0]
----
<1> bitwise and
<2> bitwise and returns common bits
<3> bitwise or
<4> bitwise or returns all '1' bits
<5> setting a mask to check only the last 8 bits
<6> bitwise exclusive or on self returns 0
<7> bitwise exclusive or
<8> bitwise negation

It's worth noting that the internal representation of primitive types follow the http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html[Java Language Specification]. In particular,
primitive types are signed, meaning that for a bitwise negation, it is always good to use a mask to retrieve only the necessary bits.

In Groovy, bitwise operators have the particularity of being <<Operator-Overloading,overloadable>>, meaning that you can define the behavior of those operators for any kind of object.

== Conditional operators

=== Not operator

The "not" operator is represented with an exclamation mark (`!`) and inverts the result of the underlying boolean expression. In
particular, it is possible to combine the `not` operator with the <<Groovy-Truth,Groovy truth>>:

[source,groovy]
----
include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=conditional_op_not,indent=0]
----
<1> the negation of `true` is `false`
<2> 'foo' is a non empty string, evaluating to `true`, so negation returns `false`
<3> '' is an empty string, evaluating to `false`, so negation returns `true`

=== Ternary operator

The ternary operator is a shortcut expression that is equivalent to an if/else branch assigning some value to a variable.

Instead of:
[source,groovy]
----
include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=conditional_op_ternary_if,indent=0]
----

You can write:
[source,groovy]
----
include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=conditional_op_ternary_ternary,indent=0]
----

The ternary operator is also compatible with the <<Groovy-Truth,Groovy truth>>, so you can make it even simpler:

[source,groovy]
----
include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=conditional_op_ternary_groovytruth,indent=0]
----

=== Elvis operator

The "Elvis operator" is a shortening of the ternary operator. One instance of where this is handy is for returning
a 'sensible default' value if an expression resolves to `false` or `null`. A simple example might look like this:

[source,groovy]
----
include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=conditional_op_elvis,indent=0]
----
<1> with the ternary operator, you have to repeat the value you want to assign
<2> with the Elvis operator, the value which is tested is used if it is not `false` or `null`

Usage of the Elvis operator reduces the verbosity of your code and reduces the risks of errors in case of refactorings,
by removing the need to duplicate the expression which is tested in both the condition and the positive return value.

== Object operators

=== Safe navigation operator (TBD)

The Safe Navigation operator is used to avoid a `NullPointerException`. Typically when you have a reference to an object
you might need to verify that it is not `null` before accessing methods or properties of the object. To avoid this, the safe
navigation operator will simply return `null` instead of throwing an exception, like so:

[source,groovy]
----
include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=nullsafe,indent=0]
----
<1> `find` will return a `null` instance
<2> use of the null-safe operator prevents from a `NullPointerException`
<3> result is `null`

=== Direct field access operator

Normally in Groovy, when you write code like this:

[source,groovy]
----
include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=direct_field_class,indent=0]
----
<1> public field `name`
<2> a getter for `name` that returns a custom string
<3> calls the getter

The `user.name` call triggers a call to the property of the same name, that is to say, here, to the getter for `name`. If
you want to retrieve the field instead of calling the getter, you can use the direct field access operator:

[source,groovy]
----
include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=direct_field_op,indent=0]
----
<1> use of `.@` forces usage of the field instead of the getter

=== Method reference operator

The method reference operator (`.&`) call be used to store a reference to a method in a variable, in order to call it
later:

[source,groovy]
----
include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=method_reference,indent=0]
----
<1> the `str` variable contains a `String`
<2> we store a reference to the `toUpperCase` method on the `str` instance inside a variable named `fun`
<3> `fun` can be called like a regular method
<4> we can check that the result is the same as if we had called it directly on `str`

There are multiple advantages in using method references. First of all, the type of such a method reference is
a `groovy.lang.Closure`, so it can be used in any place a closure would be used. In particular, it is suitable to
convert an existing method for the needs of the strategy pattern:

[source,groovy]
----
include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=method_reference,indent=0]
----
<1> the `transform` method takes each element of the list and calls the `action` closure on them, returning a new list
<2> we define a function that takes a `Person` a returns a `String`
<3> we create a method reference on that function
<4> we create the list of elements we want to collect the descriptors
<5> the method reference can be used where a `Closure` was expected

Method references are bound by the receiver and a method name. Arguments are resolved at runtime, meaning that if you have
multiple methods with the same name, the syntax is not different, only resolution of the appropriate method to be called
will be done at runtime:

[source,groovy]
----
include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=method_reference_dispatch,indent=0]
----
<1> define an overloaded `doSomething` method accepting a `String` as an argument
<2> define an overloaded `doSomething` method accepting an `Integer` as an argument
<3> create a single method reference on `doSomething`, without specifying argument types
<4> using the method reference with a `String` calls the `String` version of `doSomething`
<5> using the method reference with an `Integer` calls the `Integer` version of `doSomething`

== Regular expression operators

=== Pattern operator

The pattern operator (`~`) provides a simple way to create a `java.util.regex.Pattern` instance:

[source,groovy]
----
include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=pattern_op,indent=0]
----

while in general, you find the pattern operator with an expression in a slashy-string, it can be used with any kind of
`String` in Groovy:

[source,groovy]
----
include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=pattern_op,indent=0]
----
<1> using single quote strings
<2> using double quotes strings
<3> the dollar-slashy string lets you use slashes and the dollar sign without having to escape them
<4> you can also use a GString!

=== Find operator

Alternatively to building a pattern, you can directly use the find operator `=~` to build a `java.util.regex.Matcher`
instance:

[source,groovy]
----
include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=pattern_matcher_op,indent=0]
----
<1> `~=` creates a matcher against the `text` variable, using the pattern on the right hand side
<2> the return type of `~=` is a `Matcher`
<3> equivalent to calling `if (!m.find())`

Since a `Matcher` coerces to a `boolean` by calling its `find` method, the `=~` operator is consistent with the simple
use of Perl's `=~` operator, when it appears as a predicate (in `if`, `while`, etc.).

=== Match operator

The match operator (`==~`) is a slight variation of the find operator, that does not return a `Matcher` but a boolean
and requires a strict match of the input string:

[source,groovy]
----
include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=pattern_matcher_strict_op,indent=0]
----
<1> `~==` matches the subject with the regular expression, but match must be strict
<2> the return type of `~==` is therefore a `boolean`
<3> equivalent to calling `if (text ==~ /match/)`

== Other operators (TBD)

=== Spread operator

The Spread Operator (`.*`) is used to invoke an action on all items of an aggregate object. It is equivalent to calling the action on each item
and collecting the result into a list:

[source,groovy]
----
include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=spreaddot,indent=0]
----
<1> build a list of `Car` items. The list is an aggregate of objects.
<2> call the spread operator on the list, accessing the `make` property of each item
<3> returns a list of strings corresponding to the collection of `make` items

The spread operator is null-safe, meaning that if an element of the collection is null, it will return null instead of throwing a `NullPointerException`:

[source,groovy]
----
include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=spreaddot_nullsafe,indent=0]
----
<1> build a list for which of of the elements is `null`
<2> using the spread operator will *not* throw a `NullPointerException`
<3> the receiver might also be null, in which case the return value is `null`

The spread operator can be used on any class which implements the `Iterable` interface:

[source,groovy]
----
include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=spreaddot_iterable,indent=0]
----

==== Spreading method arguments

There may be situations when the arguments of a method call can be found in a list that you need to adapt to the method
arguments. In such situations, you can use the spread operator to call the method. For example, imagine you have the
following method signature:

[source,groovy]
----
include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=spreadmethodargs_method,indent=0]
----

then if you have the following list:

[source,groovy]
----
include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=spreadmethodargs_args,indent=0]
----

you can call the method without having to define intermediate variables:

[source,groovy]
----
include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=spreadmethodargs_assert,indent=0]
----

It is even possible to mix normal arguments with spread ones:

[source,groovy]
----
include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=spreadmethodargs_mixed,indent=0]
----


==== Spread list elements (TBD)
==== Spread map elements (TBD)
=== Range operator (TBD)
=== Spaceship operator (TBD)
=== Subscript operator (TBD)
=== Membership operator (TBD)
=== Identity operator (TBD)
=== Coercion operator (TBD)
=== Diamond operator (TBD)
=== Call operator (TBD)

== Operator precedence (TBD)

[[Operator-Overloading]]
== Operator overloading (TBD)
