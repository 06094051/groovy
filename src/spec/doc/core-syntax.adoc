= Syntax
:toc:
:icons: font
:linkcss!:

This chapter covers the syntax of the Groovy programming language.
The grammar of the language derives from the Java grammar,
but enhances it with specific constructs for Groovy, and allows certain simplifications.

== Comments

=== Single line comment

Single line comments start with +//+ and can be found at any position in the line.
The characters following +//+, till the end of the line, are considered part of the comment.

[source,groovy]
----
include::../test/SyntaxTest.groovy[tags=single_line_comment,indent=0]
----

=== Multiline comment

A multiline comment starts with +/\*+ and can be found at any position in the line.
The characters following +/*+ will be considered part of the comment, including new line characters,
up to the first +*/+ closing the comment.
Multiline comments can thus be put at the end of a statement, or even inside a statement.

[source,groovy]
----
include::../test/SyntaxTest.groovy[tags=multiline_comment,indent=0]
----

=== GroovyDoc comment

Similarly to multiline comments, GroovyDoc comments are multiline, but start with +/\**+ and end with +\*/+.
Lines following the first GroovyDoc comment line can optionally start with a star +\*+.
Those comments are associated with:

* type definitions (classes, interfaces, enums, annotations),
* fields and properties definitions
* methods definitions

Although the compiler will not complain about JavaDoc comments not being associated with the above language elements,
you should prepend those constructs with the comment right before it.

[source,groovy]
----
include::../test/SyntaxTest.groovy[tags=groovydoc_comment,indent=0]
----

GroovyDoc follows the same conventions as Java's own JavaDoc.
So you'll be able to use the same tags as with JavaDoc.

=== Shebang line

Beside the single line comment, there is a special line comment, often called the _shebang_ line understood by UNIX systems
which allows scripts to be run directly from the command-line, provided you have installed the Groovy distribution
and the +groovy+ command is available on the +PATH+.

[source,groovy]
----
include::../test/SyntaxTest.groovy[tags=shebang_comment_line,indent=0]
----

NOTE: The +#+ character must be the first character of the file. Any indentation would yield a compilation error.

== Keywords

The following list represents all the keywords of the Groovy language:

[cols="1,1,1,1"]
.Keywords
|===
|as
|assert
|break
|case

|catch
|class
|const
|continue

|def
|default
|do
|else

|enum
|extends
|false
|finally

|for
|goto
|if
|implements

|import
|in
|instanceof
|interface

|new
|null
|package
|return

|super
|switch
|this
|throw

|throws
|true
|try
|while

|===

== Identifiers

=== Normal identifiers

Identifiers start with a letter, a dollar or an underscore.
They cannot start with a number.

A letter can be in the following ranges:

* 'a' to 'z' (lowercase ascii letter)
* 'A' to 'Z' (uppercase ascii letter)
* '\u00C0' to '\u00D6'
* '\u00D8' to '\u00F6'
* '\u00F8' to '\u00FF'
* '\u0100' to '\uFFFE'

Then following characters can contain letters and numbers.

Here are a few examples of valid identifiers (here, variable names):

[source,groovy]
----
include::../test/SyntaxTest.groovy[tags=valid_identifiers,indent=0]
----

But the following ones are invalid identifiers:

[source,groovy]
----
include::../test/SyntaxTest.groovy[tags=invalid_identifiers,indent=0]
----

All keywords are also valid identifiers when following a dot:

[source,groovy]
----
include::../test/SyntaxTest.groovy[tags=keywords_valid_id_after_dot,indent=0]
----

=== Quoted identifiers

Quoted identifiers appear after the dot of a dotted expression.
For instance, the +name+ part of the +person.name+ expression can be quoted with +person."name"+ or +person.\'name'+.
This is particularly interesting when certain identifiers contain illegal characters that are forbidden by the Java Language Specification,
but which are allowed by Groovy when quoted. For example, characters like a dash, a space, an exclamation mark, etc.

[source,groovy]
----
include::../test/SyntaxTest.groovy[tags=quoted_id,indent=0]
----

As we shall see in the <<all-strings,following section on strings>>, Groovy provides different string literals.
All kind of strings are actually allowed after the dot:

[source,groovy]
----
include::../test/SyntaxTest.groovy[tags=quoted_id_with_all_strings,indent=0]
----

There's a difference between plain character strings and Groovy's GStrings (interpolated strings),
as in that the latter case, the interpolated values are inserted in the final string for evaluating the whole identifier:

[source,groovy]
----
include::../test/SyntaxTest.groovy[tags=quoted_id_with_gstring,indent=0]
----

[[all-strings]]
== Strings

Text literals are represented in the form of chain of characters called strings.
Groovy lets you instantiate +java.lang.String+ objects, as well as GStrings (+groovy.lang.GString+)
which are also called _interpolated strings_ in other programming languages.

=== Single quoted string

Single quoted strings are a series of characters surounded by single quotes:

[source,groovy]
----
include::../test/SyntaxTest.groovy[tags=quoted_id_with_gstring,indent=0]
----

NOTE: Single quoted strings are plain +java.lang+String+ and don't support interpolation.

=== Triple single quoted string

Triple single quoted strings are a series of characters surrounded by single quotes:

[source,groovy]
----
include::../test/SyntaxTest.groovy[tags=string_1,indent=0]
----

NOTE: Triple single quoted strings are plain +java.lang+String+ and don't support interpolation.

Triple single quoted strings are multiline.
You can span the content of the string across line boundaries without the need to split the string in several pieces, without contatenation or newline escape characters:

[source,groovy]
----
include::../test/SyntaxTest.groovy[tags=triple_single_1,indent=0]
----

If your code is indented, for example in the body of the method of a class, your string will contain the whitespace of the indentation.
The Groovy Development Kit contains methods for stripping out the indentation with the +String#stripIndent()+ method,
and with the +String#stripMargin()+ method that takes a delimiter character to identify the text to remove from the beginning of a string.

When creating a string as follows:

[source,groovy]
----
include::../test/SyntaxTest.groovy[tags=triple_single_2,indent=0]
----

You will notice that the resulting string contains a newline character as first character.
It is possible to strip that character by escaping the newline with a backslash:

[source,groovy]
----
include::../test/SyntaxTest.groovy[tags=triple_single_3,indent=0]
----

==== Escaping special characters

You can escape single quotes with the the backslash character to avoid terminating the string literal:

[source,groovy]
----
include::../test/SyntaxTest.groovy[tags=string_2,indent=0]
----

And you can escape the escape character itself with a double backslash:

[source,groovy]
----
include::../test/SyntaxTest.groovy[tags=string_3,indent=0]
----

Some special characters also use the backslash as escape character:

[cols="1,2" options="header"]
|====
|Escape sequence
|Character

|'\t'
|tabulation

|'\b'
|backspace

|'\n'
|newline

|'\r'
|carriage return

|'\f'
|formfeed
|====

==== Unicode escape sequence

For characters that are not present on your keyboard, you can use unicode escape sequances: 
a backslash, followed by 'u', then 4 hexadecimal digits.

For example, the Euro currency symbol can be represented with:

[source,groovy]
----
include::../test/SyntaxTest.groovy[tags=string_4,indent=0]
----

=== Double quoted string

Double quoted strings are a series of characters surrounded by double quotes:

[source,groovy]
----
include::../test/SyntaxTest.groovy[tags=string_5,indent=0]
----

NOTE: Double quoted strings are plain +java.lang.String+ if there's no interpolated expression, 
but are +groovy.lang.GString+ instances if interpolation is present.

==== String interpolation

Any Groovy expression can be interpolated in all string literals, apart from single and triple single quoted strings.
Interpolation is the act of replacing a placeholder in the string with its value upon evaluation of the string.
The placeholder expressions are surrounded by +${}+ or prefixed with +$+ for dotted expressions.
The expression value inside the placeholder is evaluated to its string representation when the GString is passed to a method taking a String as argument by calling +toString()+ on that expression.

Here, we have a string with a placeholder referencing a local variable:

[source,groovy]
----
include::../test/SyntaxTest.groovy[tags=gstring_1,indent=0]
----

But any Groovy expression is valid, as we can see in this example with an arithmetic expression:

[source,groovy]
----
include::../test/SyntaxTest.groovy[tags=gstring_2,indent=0]
----

[NOTE]
Not only expressions are actually allowed in between the +${}+ placeholder. Statements are also allowed, but a statement's value is just +null+. 
So if several statements are inserted in that placeholder, the last one should somehow return a meaningful value to be inserted. 
For instance, +"The sum of 1 and 2 is equal to ${def a = 1; def b = 2; a + b}"+ is supported and works as expected but a good practice is usually to stick to simple expressions inside GString placeholders.

In addition to +${}+ placeholders, we can also use a lone +$+ sign prefixing a dotted expression:

[source,groovy]
----
include::../test/SyntaxTest.groovy[tags=gstring_3,indent=0]
----

But only dotted expressions of the form +a.b+, +a.b.c+, etc, are valid, but expressions that would contain parentheses like method calls, curly braces for closures, or arithmetic operators would be invalid.
Given the following variable definition of a number:

[source,groovy]
----
include::../test/SyntaxTest.groovy[tags=gstring_4,indent=0]
----

The following statement will throw a +groovy.lang.MissingPropertyException+ because Groovy believes you're trying to access the +toString+ property of that number, which doesn't exist:

[source,groovy]
----
include::../test/SyntaxTest.groovy[tags=gstring_5,indent=0]
----

NOTE: You can think of +"$number.toString()"+ as being interpreted by the parser as +"${number.toString}()"+.

=== Triple double quoted string

Triple double quoted strings behave like double quoted strings, with the addition that they are multiline, like the triple single quoted strings.

[source,groovy]
----
include::../test/SyntaxTest.groovy[tags=triple_double_1,indent=0]
----


=== Slashy string
=== Dollar slashy string

=== String summary table



=== Characters

Unlike Java, Groovy doesn't have an explicit character literal.
However, you can be explicit about making a Groovy string an actual character, by three different means:

[source,groovy]
----
include::../test/SyntaxTest.groovy[tags=char,indent=0]
----
<1> by being explicit when declaring a variable holding the character by specifying the +char+ type
<2> by using type coercion with the +as+ operator
<3> by using a cast to char operation

NOTE: The first option (&#x278A;) is interesting when the character is held in a variable,
while the other two (&#x278B; and &#x278C;) are more interesting when a char value must be passed as argument of a method call.

=== Useful extension methods on Strings and GStrings

== Numbers

=== Integer literal



=== Floating point literal



NOTE: Decimal numbers can't be represented using a binary, octal or hexadecimal representation.

=== Binary literal

In Java 6 and before, as well as in Groovy, numbers could be represented in decimal, octal and hexadecimal bases, and with Java 7 and Groovy 2, you can use a binary notation with the ++0b++ prefix:

[source,groovy]
----
include::../test/SyntaxTest.groovy[tags=binary_literal_example,indent=0]
----

=== Octal literal

Octal numbers are specified in the typical format of ++0++ followed by octal digits.

[source,groovy]
----
include::../test/SyntaxTest.groovy[tags=octal_literal_example,indent=0]
----

=== Hexadecimal literal

Hexadecimal numbers are specified in the typical format of ++0x++ followed by hex digits.

[source,groovy]
----
include::../test/SyntaxTest.groovy[tags=hexadecimal_literal_example,indent=0]
----

=== Underscore in literal

When writing long literal numbers, it’s harder on the eye to figure out how some numbers are grouped together, for example with groups of thousands, of words, etc. By allowing you to place underscore in number literals, it’s easier to spot those groups:

[source,groovy]
----
include::../test/SyntaxTest.groovy[tags=underscore_in_number_example,indent=0]
----

=== Number type suffixes

We can force an number (including binary, octals and hexadecimals) to have a specific type by giving a suffix (see table bellow), either uppercase or lowercase.

[cols="1,2" options="header"]
|====
|Type
|Suffix

|BigInteger
|G

|Long
|L

|Integer
|I

|BigDecimal
|G

|Double
|D

|Float
|F
|====

Examples:

[source,groovy]
----
include::../test/SyntaxTest.groovy[tags=number_type_suffixes_example,indent=0]
----

== Booleans

Boolean is a special data type that is used to represent truth values: ++true++ and ++false++.
Use this data type for simple flags that track true/false <<_conditional_operators,conditions>>.

Boolean values can be stored in variables, just like any other data type:

[source,groovy]
----
include::../test/SyntaxTest.groovy[tags=variable_store_boolean_value,indent=0]
----

++true++ and ++false++ are the only two primitive boolean values.
But more complex boolean expressions can be represented using <<_bitwise_and_logical_operators,logical operators>>.
In addition, Groovy has <<_the_groovy_truth,special rules>> (often referred to as _Groovy Truth_) for coercing non-boolean objects to a boolean value.

== Arrays

== Lists

== Maps

=== String keys
=== Parenthesized keys
